---------- START OF FILE: backend/app/api/backend_logs.py ----------

from fastapi import APIRouter, Depends, HTTPException, Query
from app.core.security import get_current_active_user
from pathlib import Path
import os

router = APIRouter(
    prefix="/api/logs/backend",
    tags=["backend-logs"],
    dependencies=[Depends(get_current_active_user)]
)

LOG_DIR = Path(os.getenv("HIDS_LOG_DIR", "logs")).resolve()

def _safe_join(filename: str) -> Path:
    fp = (LOG_DIR / filename).resolve()
    if not str(fp).startswith(str(LOG_DIR)):
        raise HTTPException(status_code=400, detail="Invalid path")
    return fp

@router.get("/files")
def list_files():
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    files = [f.name for f in LOG_DIR.iterdir() if f.is_file() and f.name.lower().endswith((".log", ".log.txt", ".txt"))]
    files.sort()
    return {"files": files or ["app.log"]}

@router.get("")
def read_logs(
    file: str = Query("app.log"),
    page: int = Query(1, ge=1),
    limit: int = Query(15, ge=1, le=500),
    level: str | None = Query(None, description="DEBUG|INFO|WARNING|ERROR|CRITICAL"),
    contains: str | None = Query(None),
):
    LOG_DIR.mkdir(parents=True, exist_ok=True)
    fp = _safe_join(file)
    if not fp.exists():
        return {"file": file, "page": 1, "page_count": 1, "lines": []}

    lines = fp.read_text(encoding="utf-8", errors="ignore").splitlines()

    def parse(line: str):
        l = line.strip()
        lv = None
        # Naïf : détecte un niveau de log standard
        for cand in ["DEBUG","INFO","WARNING","ERROR","CRITICAL"]:
            if f" {cand} " in l or l.startswith(cand) or f"[{cand}]" in l:
                lv = cand
                break
        # L'horodatage n'est pas garanti, on retourne la ligne brute pour la lisibilité
        return {"ts": "", "level": lv, "msg": l, "text": l}

    rows = [parse(l) for l in lines]

    if level:
        rows = [r for r in rows if (r["level"] or "").upper() == level.upper()]
    if contains:
        s = contains.lower()
        rows = [r for r in rows if s in (r["msg"] or "").lower()]

    total = len(rows)
    page_count = max(1, (total + limit - 1) // limit)
    page = min(page, page_count)
    start = (page - 1) * limit
    end = start + limit
    return {"file": file, "page": page, "page_count": page_count, "lines": rows[start:end]}

---------- END OF FILE: backend/app/api/backend_logs.py ----------


---------- START OF FILE: backend/app/api/hids_logs.py ----------

from fastapi import APIRouter, Depends, Query, HTTPException
from app.core.security import get_current_active_user
from pathlib import Path
import os
import re

router = APIRouter(
    tags=["hids-logs"],
    dependencies=[Depends(get_current_active_user)]
)

LOG_DIR = Path(os.getenv("HIDS_LOG_DIR", "logs")).resolve()

# Regex pour parser les logs HIDS
HIDS_LOG_REGEX = re.compile(r"^(\d{4}-\d{2}-\d{2})\s(\d{2}:\d{2}:\d{2}),(\d{3})\s\|\s([A-Z]+)\s\|\s(.+?)\s\|\s(.+)$")
HIDS_ALERT_REGEX = re.compile(r"^(\d{4}-\d{2}-\d{2})\s(\d{2}:\d{2}:\d{2}),(\d{3})\s\|\s([A-Z]+)\s\|\s(.+)$")

def parse_hids_log(line: str):
    """Parse une ligne de log HIDS et retourne un dictionnaire."""
    line = line.strip()
    if not line:
        return None
    
    # Tente d'abord de faire correspondre la regex standard (avec la source)
    match = HIDS_LOG_REGEX.match(line)
    if match:
        date, time, ms, level, source, message = match.groups()
        return {
            "ts": f"{date}T{time}.{ms}Z",
            "level": level,
            "source": source.strip(),
            "msg": message.strip(),
            "text": line
        }

    # Tente de faire correspondre la regex alternative (sans la source)
    match = HIDS_ALERT_REGEX.match(line)
    if match:
        date, time, ms, level, message = match.groups()
        return {
            "ts": f"{date}T{time}.{ms}Z",
            "level": level,
            "source": "",
            "msg": message.strip(),
            "text": line
        }
    
    # Si aucune regex ne correspond, retourne la ligne brute
    return {
        "ts": None,
        "level": "RAW",
        "source": "",
        "msg": line,
        "text": line
    }

def read_log_file(filename: str):
    """Lit un fichier de log et renvoie les lignes parsées."""
    fp = (LOG_DIR / filename).resolve()
    
    if not str(fp).startswith(str(LOG_DIR)):
        raise HTTPException(status_code=400, detail="Invalid path")

    if not fp.exists():
        return []

    try:
        lines = fp.read_text(encoding="utf-8", errors="ignore").splitlines()
        parsed_lines = [parse_hids_log(line) for line in lines]
        return [l for l in parsed_lines if l is not None]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error reading file: {e}")

@router.get("/hids")
def get_hids_logs(
    log_type: str = Query("activity", description="activity|alerts"),
    page: int = Query(1, ge=1),
    limit: int = Query(15, ge=1, le=500),
    level: str | None = Query(None, description="DEBUG|INFO|WARNING|ERROR|CRITICAL"),
    contains: str | None = Query(None),
):
    """
    Endpoint pour récupérer les logs d'activité ou d'alerte.
    """
    if log_type == "alerts":
        filename = "alerts.log"
    else:
        filename = "hids.log"
    
    all_logs = read_log_file(filename)
    
    # Filtrer les logs
    filtered_logs = [
        log for log in all_logs
        if (not level or log['level'].lower() == level.lower()) and
           (not contains or contains.lower() in log['msg'].lower())
    ]
    
    # Inverser l'ordre pour les plus récents en premier
    filtered_logs.reverse()

    # Paginer les résultats
    total = len(filtered_logs)
    page_count = max(1, (total + limit - 1) // limit)
    page = min(page, page_count)
    start_index = (page - 1) * limit
    end_index = start_index + limit
    paginated_logs = filtered_logs[start_index:end_index]
    
    return {
        "lines": paginated_logs,
        "total": total,
        "page_count": page_count
    }

---------- END OF FILE: backend/app/api/hids_logs.py ----------


---------- START OF FILE: backend/app/api/logs.py ----------

# backend/app/api/logs.py
import os
import re
from pathlib import Path
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, Depends, Query, HTTPException
from pydantic import BaseModel, Field

from app.core.security import get_current_active_user

# ⚠️ Définir le router AVANT d'utiliser les décorateurs
router = APIRouter(
    prefix="/logs",
    tags=["logs"],
    dependencies=[Depends(get_current_active_user)]
)

LOG_DIR = Path(os.getenv("HIDS_LOG_DIR", "logs")).resolve()

# Regex pour les logs d'activité et d'alerte avec et sans la source
HIDS_LOG_REGEX_FULL = re.compile(
    r"^(\d{4}-\d{2}-\d{2})\s(\d{2}:\d{2}:\d{2}),(\d{3})\s\|\s([A-Z]+)\s\|\s(.+?)\s\|\s(.+)$"
)
HIDS_LOG_REGEX_NO_SOURCE = re.compile(
    r"^(\d{4}-\d{2}-\d{2})\s(\d{2}:\d{2}:\d{2}),(\d{3})\s\|\s([A-Z]+)\s\|\s(.+)$"
)

def parse_log_line(line: str):
    """Parse une ligne de log HIDS et retourne un dictionnaire."""
    line = line.strip()
    if not line:
        return None

    match = HIDS_LOG_REGEX_FULL.match(line)
    if match:
        date, time, ms, level, source, message = match.groups()
        return {
            "ts": f"{date}T{time}.{ms}Z",
            "level": level,
            "source": source.strip(),
            "msg": message.strip(),
            "text": line
        }

    match = HIDS_LOG_REGEX_NO_SOURCE.match(line)
    if match:
        date, time, ms, level, message = match.groups()
        return {
            "ts": f"{date}T{time}.{ms}Z",
            "level": level,
            "source": "",
            "msg": message.strip(),
            "text": line
        }

    return {
        "ts": None,
        "level": "RAW",
        "source": "",
        "msg": line,
        "text": line
    }

def read_log_file(filename: str):
    """Lit un fichier de log et renvoie les lignes parsées."""
    fp = (LOG_DIR / filename).resolve()

    if not str(fp).startswith(str(LOG_DIR)):
        raise HTTPException(status_code=400, detail="Invalid path")

    if not fp.exists():
        return []

    try:
        lines = fp.read_text(encoding="utf-8", errors="ignore").splitlines()
        parsed_lines = [parse_log_line(line) for line in lines]
        return [l for l in parsed_lines if l is not None]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error reading file: {e}")

@router.get("/hids")
def get_hids_logs(
    log_type: str = Query("activity", description="Type de log: 'activity' ou 'alerts'"),
    page: int = Query(1, ge=1),
    limit: int = Query(15, ge=1, le=500),
    level: Optional[str] = Query(None, description="DEBUG|INFO|WARNING|ERROR|CRITICAL"),
    contains: Optional[str] = Query(None),
):
    """
    Endpoint unifié pour récupérer les logs d'activité ou d'alerte.
    """
    if log_type not in ["activity", "alerts"]:
        raise HTTPException(status_code=400, detail="Log type must be 'activity' or 'alerts'")

    filename = "hids.log" if log_type == "activity" else "alerts.log"
    all_logs = read_log_file(filename)

    filtered_logs = [
        log for log in all_logs
        if (not level or (log.get('level') or '').lower() == level.lower()) and
            (not contains or contains.lower() in (log.get('msg') or '').lower())
    ]

    filtered_logs.reverse()

    total = len(filtered_logs)
    page_count = max(1, (total + limit - 1) // limit)
    page = min(page, page_count)
    start_index = (page - 1) * limit
    end_index = start_index + limit
    paginated_logs = filtered_logs[start_index:end_index]

    return {
        "lines": paginated_logs,
        "total": total,
        "page_count": page_count
    }

# ---------- Clear & Purge (compat front) ----------

class ClearBody(BaseModel):
    type: str = Field("activity", description="'activity' | 'alerts'")

class PurgeBody(BaseModel):
    type: str                         # 'activity' | 'alerts'
    level: Optional[str] = None
    from_: Optional[str] = Field(None, alias="from")  # accepte 'from' depuis le front
    to: Optional[str] = None

def _parse_iso(s: Optional[str]) -> Optional[datetime]:
    if not s:
        return None
    try:
        return datetime.fromisoformat(s.replace("Z", "+00:00"))
    except Exception:
        return None

def _ensure_admin(current_user=Depends(get_current_active_user)):
    if not getattr(current_user, "is_admin", False):
        raise HTTPException(status_code=403, detail="Admin privileges required")
    return current_user

@router.post("/hids/clear", dependencies=[Depends(_ensure_admin)])
def clear_hids_logs(body: ClearBody):
    """
    Vide entièrement le fichier de logs demandé.
    Corps attendu (front): { "type": "activity" | "alerts" }
    """
    log_type = body.type
    if log_type not in ["activity", "alerts"]:
        raise HTTPException(status_code=400, detail="Log type must be 'activity' or 'alerts'")

    filename = "hids.log" if log_type == "activity" else "alerts.log"
    fp = (LOG_DIR / filename).resolve()

    if not str(fp).startswith(str(LOG_DIR)):
        raise HTTPException(status_code=400, detail="Invalid path")

    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        if fp.exists():
            fp.write_text("", encoding="utf-8")
        return {"status": "success", "message": f"Log file '{filename}' cleared."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error clearing file: {e}")

@router.post("/hids/purge", dependencies=[Depends(_ensure_admin)])
def purge_hids_logs(body: PurgeBody):
    """
    Supprime les lignes correspondant aux filtres.
    Corps attendu (front): { type, level?, from?, to? }
    """
    if body.type not in ["activity", "alerts"]:
        raise HTTPException(status_code=400, detail="type must be 'activity' or 'alerts'")

    filename = "hids.log" if body.type == "activity" else "alerts.log"
    fp = (LOG_DIR / filename).resolve()

    if not str(fp).startswith(str(LOG_DIR)):
        raise HTTPException(status_code=400, detail="Invalid path")

    if not fp.exists():
        return {"status": "success", "message": "Nothing to purge."}

    lines = fp.read_text(encoding="utf-8", errors="ignore").splitlines()
    parsed = [parse_log_line(l) for l in lines]

    t_from = _parse_iso(body.from_)
    t_to = _parse_iso(body.to)
    level = (body.level or "").upper() if body.level else None

    def should_be_purged(log):
        """Retourne True si la ligne doit être supprimée."""
        if not log:
            return False

        # Si aucun filtre n'est actif, on ne supprime rien
        if not level and not t_from and not t_to:
            return False

        # Vérifier le niveau
        if level and (log.get("level") or "").upper() != level:
            return False # Le niveau ne correspond pas, on ne supprime pas

        # Vérifier la période
        ts = log.get("ts")
        t = _parse_iso(ts) if ts else None
        if t_from and (not t or t < t_from):
            return False # En dehors de la période, on ne supprime pas
        if t_to and (not t or t > t_to):
            return False # En dehors de la période, on ne supprime pas

        return True # Tous les filtres actifs correspondent, on supprime

    kept_text = [p["text"] if p else lines[i] for i, p in enumerate(parsed) if not should_be_purged(p)]
    fp.write_text("\n".join(kept_text) + ("\n" if kept_text else ""), encoding="utf-8")
    purged = len(lines) - len(kept_text)
    return {"status": "success", "purged": purged}

---------- END OF FILE: backend/app/api/logs.py ----------


---------- START OF FILE: backend/app/api/monitoring.py ----------

# File: backend/app/api/monitoring.py
from typing import List, Any
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.exc import IntegrityError
from datetime import datetime

# Scheduler + scan tasks
from app.core.scheduler import add_interval_job, remove_job, FREQ_SECONDS
from app.services.scan_tasks import scan_file, scan_folder, scan_ip

# Schemas (Pydantic)
from app.models.monitoring import (
    FileItemCreate, FileItemRead,
    IPItemCreate, IPItemRead,
    FolderItemCreate, FolderItemRead
)

# Services (DB CRUD)
from app.services.monitoring_service import (
    get_file_items, get_file_item, create_file_item, update_file_item, delete_file_item,
    get_ip_items, get_ip_item, create_ip_item, update_ip_item, delete_ip_item,
    get_folder_items, get_folder_item, create_folder_item, update_folder_item, delete_folder_item
)

# Auth
from app.core.security import get_current_active_user
from app.db.models import User as ORMUser  # éventuellement utile

# (optionnel) mini logger
import logging
log = logging.getLogger("monitoring-api")

router = APIRouter(
    prefix="/api/monitoring",
    tags=["monitoring"],
    dependencies=[Depends(get_current_active_user)]
)

# -------------------------------------------------------------------------
# Helpers: support dict OU objet (ORM/Pydantic) de façon uniforme
# -------------------------------------------------------------------------

def _val(obj: Any, name: str, default: Any = None) -> Any:
    """Récupère un champ soit en attribut, soit en clé dict, sinon default."""
    if obj is None:
        return default
    if isinstance(obj, dict):
        return obj.get(name, default)
    return getattr(obj, name, default)

def _schedule_file(item: Any) -> None:
    """(Re)pose un job de scan pour un File si status=active, sinon retire."""
    iid = _val(item, "id")
    if iid is None:
        return
    status = _val(item, "status", "active")
    freq = _val(item, "frequency", "hourly")
    path = _val(item, "path")

    if status == "active":
        sec = FREQ_SECONDS.get(freq, 3600)
        try:
            add_interval_job("file", iid, sec, scan_file, item_id=iid, path=path)
            log.debug(f"[scheduler] file #{iid} scheduled every {sec}s (status={status}, freq={freq})")
        except Exception as e:
            log.warning(f"[scheduler] cannot schedule file #{iid}: {e}")
    else:
        try:
            remove_job("file", iid)
            log.debug(f"[scheduler] file #{iid} job removed (status={status})")
        except Exception as e:
            log.warning(f"[scheduler] cannot remove file job #{iid}: {e}")

def _schedule_folder(item: Any) -> None:
    iid = _val(item, "id")
    if iid is None:
        return
    status = _val(item, "status", "active")
    freq = _val(item, "frequency", "hourly")
    path = _val(item, "path")

    if status == "active":
        sec = FREQ_SECONDS.get(freq, 3600)
        try:
            add_interval_job("folder", iid, sec, scan_folder, item_id=iid, path=path)
            log.debug(f"[scheduler] folder #{iid} scheduled every {sec}s (status={status}, freq={freq})")
        except Exception as e:
            log.warning(f"[scheduler] cannot schedule folder #{iid}: {e}")
    else:
        try:
            remove_job("folder", iid)
            log.debug(f"[scheduler] folder #{iid} job removed (status={status})")
        except Exception as e:
            log.warning(f"[scheduler] cannot remove folder job #{iid}: {e}")

def _schedule_ip(item: Any) -> None:
    iid = _val(item, "id")
    if iid is None:
        return
    status = _val(item, "status", "active")
    freq = _val(item, "frequency", "hourly")
    ip = _val(item, "ip")
    hostname = _val(item, "hostname", None)

    if status == "active":
        sec = FREQ_SECONDS.get(freq, 3600)
        try:
            add_interval_job("ip", iid, sec, scan_ip, item_id=iid, ip=ip, hostname=hostname)
            log.debug(f"[scheduler] ip #{iid} scheduled every {sec}s (status={status}, freq={freq})")
        except Exception as e:
            log.warning(f"[scheduler] cannot schedule ip #{iid}: {e}")
    else:
        try:
            remove_job("ip", iid)
            log.debug(f"[scheduler] ip #{iid} job removed (status={status})")
        except Exception as e:
            log.warning(f"[scheduler] cannot remove ip job #{iid}: {e}")

# -------------------------------------------------------------------------
# File monitoring endpoints
# -------------------------------------------------------------------------

@router.get("/files/{file_id}", response_model=FileItemRead)
def read_file_item(file_id: int):
    """Get a single monitored file by ID."""
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    return item

@router.get("/files", response_model=List[FileItemRead])
def read_file_items(skip: int = 0, limit: int = 100):
    return get_file_items(skip=skip, limit=limit)

@router.post("/files", response_model=FileItemRead, status_code=status.HTTP_201_CREATED)
def add_file_item(file_in: FileItemCreate):
    try:
        item = create_file_item(file_in)
        _schedule_file(item)
        return item
    except IntegrityError:
        raise HTTPException(status_code=409, detail="File path already exists")

@router.put("/files/{file_id}", response_model=FileItemRead)
def edit_file_item(file_id: int, file_in: FileItemCreate):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    item = update_file_item(file_id, file_in)
    _schedule_file(item)
    return item

@router.delete("/files/{file_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_file_item(file_id: int):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    delete_file_item(file_id)
    remove_job("file", file_id)
    return None

# -------------------------------------------------------------------------
# IP monitoring endpoints
# -------------------------------------------------------------------------

@router.get("/ips/{ip_id}", response_model=IPItemRead)
def read_ip_item(ip_id: int):
    """Get a single monitored IP by ID."""
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    return item

@router.get("/ips", response_model=List[IPItemRead])
def read_ip_items(skip: int = 0, limit: int = 100):
    return get_ip_items(skip=skip, limit=limit)

@router.post("/ips", response_model=IPItemRead, status_code=status.HTTP_201_CREATED)
def add_ip_item(ip_in: IPItemCreate):
    try:
        item = create_ip_item(ip_in)
        _schedule_ip(item)
        return item
    except IntegrityError:
        raise HTTPException(status_code=409, detail="IP address already exists")

@router.put("/ips/{ip_id}", response_model=IPItemRead)
def edit_ip_item(ip_id: int, ip_in: IPItemCreate):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    item = update_ip_item(ip_id, ip_in)
    _schedule_ip(item)
    return item

@router.delete("/ips/{ip_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_ip_item(ip_id: int):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    delete_ip_item(ip_id)
    remove_job("ip", ip_id)
    return None

# -------------------------------------------------------------------------
# Folder monitoring endpoints
# -------------------------------------------------------------------------

@router.get("/folders/{folder_id}", response_model=FolderItemRead)
def read_folder_item(folder_id: int):
    """Get a single monitored folder by ID."""
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    return item

@router.get("/folders", response_model=List[FolderItemRead])
def read_folder_items(skip: int = 0, limit: int = 100):
    return get_folder_items(skip=skip, limit=limit)

@router.post("/folders", response_model=FolderItemRead, status_code=status.HTTP_201_CREATED)
def add_folder_item(folder_in: FolderItemCreate):
    try:
        item = create_folder_item(folder_in)
        _schedule_folder(item)
        return item
    except IntegrityError:
        raise HTTPException(status_code=409, detail="Folder already monitored")
    except Exception as e:
        if "UNIQUE constraint failed: monitored_folders.path" in str(e):
            raise HTTPException(status_code=409, detail="Folder already monitored")
        raise

@router.put("/folders/{folder_id}", response_model=FolderItemRead)
def edit_folder_item(folder_id: int, folder_in: FolderItemCreate):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    item = update_folder_item(folder_id, folder_in)
    _schedule_folder(item)
    return item

@router.delete("/folders/{folder_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_folder_item(folder_id: int):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    delete_folder_item(folder_id)
    remove_job("folder", folder_id)
    return None

# -------------------------------------------------------------------------
# Scan now endpoints
# -------------------------------------------------------------------------

@router.post("/files/{file_id}/scan-now")
def scan_now_file(file_id: int):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    # on scanne même si status=paused (action manuelle)
    scan_file(item_id=item["id"] if isinstance(item, dict) else item.id,
                path=item["path"] if isinstance(item, dict) else item.path)
    return {"executed": True, "type": "file_scan", "id": item["id"] if isinstance(item, dict) else item.id,
            "ts": datetime.utcnow().isoformat()}

@router.post("/folders/{folder_id}/scan-now")
def scan_now_folder(folder_id: int):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    scan_folder(item_id=item["id"] if isinstance(item, dict) else item.id,
                path=item["path"] if isinstance(item, dict) else item.path)
    return {"executed": True, "type": "folder_scan", "id": item["id"] if isinstance(item, dict) else item.id,
            "ts": datetime.utcnow().isoformat()}

@router.post("/ips/{ip_id}/scan-now")
def scan_now_ip(ip_id: int):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    scan_ip(item_id=item["id"] if isinstance(item, dict) else item.id,
            ip=item["ip"] if isinstance(item, dict) else item.ip,
            hostname=(item.get("hostname") if isinstance(item, dict) else getattr(item, "hostname", None)))
    return {"executed": True, "type": "ip_scan", "id": item["id"] if isinstance(item, dict) else item.id,
            "ts": datetime.utcnow().isoformat()}
---------- END OF FILE: backend/app/api/monitoring.py ----------


---------- START OF FILE: backend/app/api/reports.py ----------

# # File: backend/app/api/reports.py
# from fastapi import APIRouter, Depends, Query
# from typing import Dict, Any, List
# import os, json

# from app.core.security import get_current_active_user
# from app.db.session import SessionLocal
# from app.db.models import MonitoredFile, MonitoredFolder, MonitoredIP
# from app.api.metrics import _count_jobs_by_kind  # on réutilise la logique
# LOG_PATH = os.getenv("HIDS_LOG_PATH", "logs/hids.log")

# router = APIRouter(
#     prefix="/api",
#     tags=["reports"],
#     dependencies=[Depends(get_current_active_user)]
# )

# def _read_recent_events(limit: int = 50) -> list[dict]:
#     if not os.path.exists(LOG_PATH):
#         return []
#     with open(LOG_PATH, "r", encoding="utf-8", errors="ignore") as f:
#         lines = f.readlines()[-limit*3:]  # on lit un peu plus large
#     events = []
#     for line in lines:
#         payload = line.split("|", 2)[2].strip() if "|" in line else line.strip()
#         try:
#             ev = json.loads(payload)
#             # on ne garde que nos événements d'activité
#             if isinstance(ev, dict) and ev.get("type") in {"file_scan","folder_scan","ip_scan"}:
#                 events.append(ev)
#         except Exception:
#             continue
#     # on limite après filtrage
#     return events[-limit:]


# @router.get("/reports", summary="Generate consolidated JSON report")
# def get_report(limit_events: int = Query(50, ge=0, le=1000)) -> Dict[str, Any]:
#     """
#     Rapport JSON consolidé:
#         - métriques globales
#         - inventaire des items (actifs uniquement par défaut)
#         - derniers événements (logs d'activité)
#     """
#     db = SessionLocal()
#     try:
#         # inventaire (actifs)
#         files = db.query(MonitoredFile).filter(MonitoredFile.status == "active").all()
#         folders = db.query(MonitoredFolder).filter(MonitoredFolder.status == "active").all()
#         ips = db.query(MonitoredIP).filter(MonitoredIP.status == "active").all()

#         def _s_file(f):    return {"id": f.id, "path": f.path, "frequency": f.frequency, "status": f.status}
#         def _s_folder(d):  return {"id": d.id, "path": d.path, "frequency": d.frequency, "status": d.status}
#         def _s_ip(i):      return {"id": i.id, "ip": i.ip, "hostname": i.hostname, "frequency": i.frequency, "status": i.status}

#         jobs = _count_jobs_by_kind()
#         events = _read_recent_events(limit_events) if limit_events > 0 else []

#         return {
#             "report": {
#                 "title": "HIDS-Web JSON Report",
#                 "version": "2.0",
#             },
#             "metrics": {
#                 "monitored": {
#                     "files":   len(files),
#                     "folders": len(folders),
#                     "ips":     len(ips),
#                     "total":   len(files) + len(folders) + len(ips),
#                 },
#                 "scheduler": jobs
#             },
#             "inventory": {
#                 "files":   [_s_file(f)   for f in files],
#                 "folders": [_s_folder(d) for d in folders],
#                 "ips":     [_s_ip(i)     for i in ips],
#             },
#             "events": events[-20:] if len(events) > 20 else events
#         }
#     finally:
#         db.close()


# File: backend/app/api/reports.py
from fastapi import APIRouter, Depends, Query
from typing import Dict, Any
import os, json
from datetime import datetime

from app.core.security import get_current_active_user
from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredFolder, MonitoredIP
from app.api.metrics import _count_jobs_by_kind  # on réutilise la logique

LOG_PATH = os.getenv("HIDS_LOG_PATH", "logs/hids.log")

router = APIRouter(
    prefix="/api",
    tags=["reports"],
    dependencies=[Depends(get_current_active_user)]
)

def _read_recent_events(limit: int = 50) -> list[dict]:
    if not os.path.exists(LOG_PATH):
        return []
    with open(LOG_PATH, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()[-limit*3:]  # on lit un peu plus large
    events = []
    for line in lines:
        payload = line.split("|", 2)[2].strip() if "|" in line else line.strip()
        try:
            ev = json.loads(payload)
            if isinstance(ev, dict) and ev.get("type") in {"file_scan","folder_scan","ip_scan"}:
                events.append(ev)
        except Exception:
            continue
    return events[-limit:]

@router.get("/reports", summary="Generate consolidated JSON report")
def get_report(limit_events: int = Query(50, ge=0, le=1000)) -> Dict[str, Any]:
    """
    Rapport JSON consolidé:
        - métriques globales
        - inventaire des items (tous statuts confondus)
        - derniers événements (logs d'activité)
    """
    db = SessionLocal()
    try:
        # inventaire (TOUS les statuts, pas seulement "active")
        files = db.query(MonitoredFile).all()
        folders = db.query(MonitoredFolder).all()
        ips = db.query(MonitoredIP).all()

        def _s_file(f):   
            return {"id": f.id, "path": f.path, "frequency": f.frequency, "status": f.status}
        def _s_folder(d): 
            return {"id": d.id, "path": d.path, "frequency": d.frequency, "status": d.status}
        def _s_ip(i):     
            return {"id": i.id, "ip": i.ip, "hostname": i.hostname, "frequency": i.frequency, "status": i.status}

        jobs = _count_jobs_by_kind()
        events = _read_recent_events(limit_events) if limit_events > 0 else []

        return {
            "report": {
                "title": "HIDS-Web JSON Report",
                "version": "2.0",
                "generatedAt": datetime.utcnow().isoformat()
            },
            "metrics": {
                "monitored": {
                    "files":   len(files),
                    "folders": len(folders),
                    "ips":     len(ips),
                    "total":   len(files) + len(folders) + len(ips),
                },
                "scheduler": jobs
            },
            "inventory": {
                "files":   [_s_file(f)   for f in files],
                "folders": [_s_folder(d) for d in folders],
                "ips":     [_s_ip(i)     for i in ips],
            },
            "events": events[-20:] if len(events) > 20 else events
        }
    finally:
        db.close()

---------- END OF FILE: backend/app/api/reports.py ----------


---------- START OF FILE: backend/app/core/config.py ----------

# backend/app/core/config.py
import logging
from pydantic import BaseSettings, Field

class Settings(BaseSettings):
    APP_NAME: str       = "HIDS-Web API"
    VERSION: str        = "2.0.0"
    API_V1_STR: str     = "/api"
    DATABASE_URL: str   = Field("sqlite:///./data/hids.db", env="DATABASE_URL")
    LOG_LEVEL: str      = Field("INFO", env="LOG_LEVEL")
    JWT_SECRET: str     = Field(..., env="JWT_SECRET")

    ALLOWED_ORIGINS: str = Field(
        default="http://localhost:5173,http://localhost:3000,https://localhost:5173,https://localhost:3000",
        description="Comma-separated list of allowed CORS origins."
    )
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()

---------- END OF FILE: backend/app/core/config.py ----------


---------- START OF FILE: backend/app/core/logging.py ----------

import logging
from logging.handlers import RotatingFileHandler
from app.core.config import settings
import os

LOG_PATH = "logs/hids.log"
os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)

handler = RotatingFileHandler(
    LOG_PATH, maxBytes=5*1024*1024, backupCount=5
)
formatter = logging.Formatter(
    "%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
handler.setFormatter(formatter)

logging.basicConfig(
    level=settings.LOG_LEVEL,
    handlers=[handler]
)
logger = logging.getLogger("hids")
---------- END OF FILE: backend/app/core/logging.py ----------


---------- START OF FILE: backend/app/core/scheduler.py ----------

# ---------------------

from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.jobstores.sqlalchemy import SQLAlchemyJobStore
from typing import Optional

FREQ_SECONDS = {
    "minutely": 60,
    "hourly": 3600,
    "daily": 86400,
    "weekly": 604800,
}

_scheduler: Optional[BackgroundScheduler] = None

def get_scheduler() -> BackgroundScheduler:
    global _scheduler
    if _scheduler is None:
        # SQLite file under ./data (persisted via docker volume)
        jobstores = {"default": SQLAlchemyJobStore(url="sqlite:///data/jobs.db")}
        _scheduler = BackgroundScheduler(timezone="UTC", jobstores=jobstores)
    return _scheduler

def _job_id(kind: str, entity_id: int) -> str:
    return f"{kind}:{entity_id}"

def add_interval_job(kind: str, entity_id: int, seconds: int, func, **job_kwargs):
    sch = get_scheduler()
    job_id = _job_id(kind, entity_id)
    try:
        sch.remove_job(job_id)
    except Exception:
        pass
    sch.add_job(
        func,
        IntervalTrigger(seconds=seconds),
        id=job_id,
        replace_existing=True,
        kwargs=job_kwargs,
    )

def remove_job(kind: str, entity_id: int):
    sch = get_scheduler()
    try:
        sch.remove_job(_job_id(kind, entity_id))
    except Exception:
        pass

def start_scheduler():
    sch = get_scheduler()
    if not sch.running:
        sch.start()

def shutdown_scheduler():
    sch = get_scheduler()
    if sch.running:
        sch.shutdown(wait=False)

---------- END OF FILE: backend/app/core/scheduler.py ----------


---------- START OF FILE: backend/app/core/security.py ----------

from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from app.core.config import settings

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from app.core.config import settings
# from app.services.auth_service import  decode_access_token
from app.db.models import User as ORMUser
from app.db.session import SessionLocal

#JWT constant
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 #delais d'expiration du token


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a JWT token, embedding 'data' and an expiration.
    
    :param data: Données à inclure dans le token.
    :param expires_delta: Durée d'expiration du token.
    :return: Token JWT.
    """
    #traduire en anglais 
    
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.JWT_SECRET, algorithm=ALGORITHM)


def decode_access_token(token: str) -> dict:
    """
    Decode and verify a JWT token, returning the payload or None if invalid.
    
    :param token: Token JWT à décoder.
    :return: Payload du token.
    """
    
    try:
        return jwt.decode(token, settings.JWT_SECRET, algorithms=[ALGORITHM])
    except JWTError:
        return None

def get_current_user(token: str = Depends(oauth2_scheme)) -> ORMUser:
    payload = decode_access_token(token)
    if not payload or "sub" not in payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid authentication credentials")
    username = payload["sub"]
    db = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.username == username).first()
    db.close()
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
    return user

def get_current_active_user(current_user: ORMUser = Depends(get_current_user)) -> ORMUser:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user")
    return current_user
---------- END OF FILE: backend/app/core/security.py ----------


---------- START OF FILE: backend/app/db/models.py ----------

# File: backend/app/db/models.py
import enum
from sqlalchemy import Column, String, Boolean, Integer, DateTime, Enum, JSON
from sqlalchemy.sql import func
from app.db.base import Base

class User(Base):
    __tablename__ = "users"

    id             = Column(Integer, primary_key=True, index=True)
    username       = Column(String, unique=True, index=True, nullable=False)
    email          = Column(String, unique=True, index=True, nullable=False)
    password_hash  = Column(String, nullable=False)
    is_active      = Column(Boolean, default=True, nullable=False)
    is_admin       = Column(Boolean, default=False, nullable=False)
    created_at     = Column(DateTime(timezone=True), server_default=func.now())
    updated_at     = Column(DateTime(timezone=True), onupdate=func.now())

class FrequencyEnum(str, enum.Enum):
    minutely = "minutely"
    hourly   = "hourly"
    daily    = "daily"
    weekly   = "weekly"

class StatusEnum(str, enum.Enum):
    active = "active"
    paused = "paused"
    stopped = "stopped"

class MonitoredFile(Base):
    __tablename__ = "monitored_files"

    id              = Column(Integer, primary_key=True, index=True)
    path            = Column(String, unique=True, nullable=False)
    frequency       = Column(Enum(FrequencyEnum, name="frequency_enum"), default=FrequencyEnum.hourly, nullable=False)
    status          = Column(Enum(StatusEnum, name="status_enum"), default=StatusEnum.active, nullable=False)
    baseline_hash   = Column(String, nullable=True)
    current_hash    = Column(String, nullable=True)
    last_scan       = Column(DateTime(timezone=True), nullable=True)
    created_at      = Column(DateTime(timezone=True), server_default=func.now())
    updated_at      = Column(DateTime(timezone=True), onupdate=func.now())

class MonitoredFolder(Base):
    __tablename__ = "monitored_folders"

    id              = Column(Integer, primary_key=True, index=True)
    path            = Column(String, unique=True, nullable=False)
    frequency       = Column(Enum(FrequencyEnum, name="frequency_enum"), default=FrequencyEnum.hourly, nullable=False)
    status          = Column(Enum(StatusEnum, name="status_enum"), default=StatusEnum.active, nullable=False)
    folder_hash     = Column(String, nullable=True)
    file_count      = Column(Integer, default=0)
    last_scan       = Column(DateTime(timezone=True), nullable=True)
    created_at      = Column(DateTime(timezone=True), server_default=func.now())
    updated_at      = Column(DateTime(timezone=True), onupdate=func.now())

class MonitoredIP(Base):
    __tablename__ = "monitored_ips"

    id              = Column(Integer, primary_key=True, index=True)
    ip              = Column(String, unique=True, nullable=False)
    hostname        = Column(String, nullable=True)
    frequency       = Column(Enum(FrequencyEnum, name="frequency_enum"), default=FrequencyEnum.hourly, nullable=False)
    status          = Column(Enum(StatusEnum, name="status_enum"), default=StatusEnum.active, nullable=False)
    last_status     = Column(JSON, nullable=True)
    last_scan       = Column(DateTime(timezone=True), nullable=True)
    created_at      = Column(DateTime(timezone=True), server_default=func.now())
    updated_at      = Column(DateTime(timezone=True), onupdate=func.now())

---------- END OF FILE: backend/app/db/models.py ----------


---------- START OF FILE: backend/app/models/alerts.py ----------

# backend/app/models/alerts.py
from pydantic import BaseModel
from typing import Any, Optional, List
from datetime import datetime

class AlertOut(BaseModel):
    id: int | None = None
    ts: datetime | None = None
    severity: str | None = None
    rule: Optional[str] = None
    entity_type: Optional[str] = None
    entity_id: Optional[int] = None
    entity_label: Optional[str] = None
    message: Optional[str] = None
    meta: Optional[Any] = None
    class Config:
        from_attributes = True

class ActivityOut(BaseModel):
    id: int | None = None
    ts: datetime | None = None
    kind: str | None = None
    entity_type: Optional[str] = None
    entity_id: Optional[int] = None
    entity_label: Optional[str] = None
    message: Optional[str] = None
    meta: Optional[Any] = None
    class Config:
        from_attributes = True

class PageOut(BaseModel):
    items: List[Any]
    count: int
    total: int

---------- END OF FILE: backend/app/models/alerts.py ----------


---------- START OF FILE: backend/app/models/monitoring.py ----------

# File: backend/app/models/monitoring.py
from pydantic import BaseModel
from typing import Literal, Optional

class MonitoredItemBase(BaseModel):
    path: str
    frequency: Literal["minutely", "hourly", "daily", "weekly"]
    status: Optional[Literal["active", "paused", "stopped"]] = "stopped"

class FileItemCreate(BaseModel):
    path: str
    frequency: Literal["minutely", "hourly", "daily", "weekly"]

class FileItemRead(MonitoredItemBase):
    id: int

    class Config:
        orm_mode = True

class FolderItemCreate(BaseModel):
    path: str
    frequency: Literal["minutely", "hourly", "daily", "weekly"]

class FolderItemRead(MonitoredItemBase):
    id: int

    class Config:
        orm_mode = True

class IPMonitoredBase(BaseModel):
    ip: str
    hostname: Optional[str]
    frequency: Literal["minutely", "hourly", "daily", "weekly"]
    status: Optional[Literal["active", "paused", "stopped"]] = "stopped"

class IPItemCreate(IPMonitoredBase):
    pass

class IPItemRead(IPMonitoredBase):
    id: int
    class Config:
        orm_mode = True
---------- END OF FILE: backend/app/models/monitoring.py ----------


---------- START OF FILE: backend/app/services/alert_service.py ----------


---------- END OF FILE: backend/app/services/alert_service.py ----------


---------- START OF FILE: backend/app/services/monitoring_service.py ----------

# File: backend/app/services/monitoring_service.py
import os, re

from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.exc import NoResultFound, IntegrityError

from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredIP, MonitoredFolder
from app.models.monitoring import FileItemCreate, IPItemCreate, FolderItemCreate

# ---- Monitored Files CRUD ----

def get_file_items(skip: int = 0, limit: int = 100) -> List[MonitoredFile]:
    db: Session = SessionLocal()
    items = db.query(MonitoredFile).offset(skip).limit(limit).all()
    db.close()
    return items


def get_file_item(file_id: int) -> Optional[MonitoredFile]:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    db.close()
    return item


def create_file_item(file_in: FileItemCreate) -> MonitoredFile:
    db: Session = SessionLocal()
    try:
        normalized_path = normalize_path(file_in.path)
        existing = db.query(MonitoredFile).filter(MonitoredFile.path == normalized_path).first()
        if existing:
            db.close()
            return existing
        db_item = MonitoredFile(path=normalized_path, frequency=file_in.frequency, status="stopped")
        db.add(db_item)
        db.commit()
        db.refresh(db_item)
        db.close()
        return db_item
    except IntegrityError:
        db.rollback()
        db.close()
        raise



def update_file_item(file_id: int, file_in: FileItemCreate) -> MonitoredFile:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"File item {file_id} not found")
    item.path = normalize_path(file_in.path)
    item.frequency = file_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_file_item(file_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ---- Monitored IPs CRUD ----

def get_ip_items(skip: int = 0, limit: int = 100) -> List[MonitoredIP]:
    db: Session = SessionLocal()
    items = db.query(MonitoredIP).offset(skip).limit(limit).all()
    db.close()
    return items


def get_ip_item(ip_id: int) -> Optional[MonitoredIP]:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    db.close()
    return item


def create_ip_item(ip_in: IPItemCreate) -> MonitoredIP:
    db: Session = SessionLocal()
    try:
        existing = db.query(MonitoredIP).filter(MonitoredIP.ip == ip_in.ip).first()
        if existing:
            db.close()
            return existing
        db_item = MonitoredIP(
            ip=ip_in.ip,
            hostname=ip_in.hostname,
            frequency=ip_in.frequency,
            status="stopped"
        )
        db.add(db_item)
        db.commit()
        db.refresh(db_item)
        db.close()
        return db_item
    except IntegrityError:
        db.rollback()
        db.close()
        raise


def update_ip_item(ip_id: int, ip_in: IPItemCreate) -> MonitoredIP:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"IP item {ip_id} not found")
    item.ip = ip_in.ip
    item.hostname = ip_in.hostname
    item.frequency = ip_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_ip_item(ip_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ---- Monitored Folders CRUD ----

def get_folder_items(skip: int = 0, limit: int = 100) -> List[MonitoredFolder]:
    db: Session = SessionLocal()
    items = db.query(MonitoredFolder).offset(skip).limit(limit).all()
    db.close()
    return items


def get_folder_item(folder_id: int) -> Optional[MonitoredFolder]:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    db.close()
    return item


def create_folder_item(folder_in: FolderItemCreate) -> MonitoredFolder:
    db: Session = SessionLocal()
    try:
        existing = db.query(MonitoredFolder).filter(MonitoredFolder.path == folder_in.path).first()
        if existing:
            db.close()
            return existing
        db_item = MonitoredFolder(path=folder_in.path, frequency=folder_in.frequency, status="stopped")
        db.add(db_item); db.commit(); db.refresh(db_item)
        db.close()
        return db_item
    except IntegrityError:
        db.rollback()
        db.close()
        raise


def update_folder_item(folder_id: int, folder_in: FolderItemCreate) -> MonitoredFolder:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"Folder item {folder_id} not found")
    item.path = normalize_path(folder_in.path) 
    item.frequency = folder_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_folder_item(folder_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ------------------------------
# ---- Status update functions ----

def update_file_status(file_id: int, status: str) -> MonitoredFile:
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
        if not item:
            raise NoResultFound(f"File item {file_id} not found")

        if status not in {"active", "paused", "stopped"}:
            raise ValueError(f"Unsupported file status: {status}")

        item.status = status

        if status == "stopped":
            # Hard stop: drop hashes so a fresh baseline is rebuilt on next run
            item.baseline_hash = None
            item.current_hash = None
        # NOTE: 'paused' NE change rien aux hashes.

        db.commit()
        db.refresh(item)
        return item
    finally:
        db.close()


def update_folder_status(folder_id: int, status: str) -> MonitoredFolder:
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
        if not item:
            raise NoResultFound(f"Folder item {folder_id} not found")

        if status not in {"active", "paused", "stopped"}:
            raise ValueError(f"Unsupported folder status: {status}")

        item.status = status

        if status == "stopped":
            # Arrêt fort: on oublie les états agrégés
            item.folder_hash = None
            item.file_count = 0
        # 'paused' : on ne touche pas

        db.commit()
        db.refresh(item)
        return item
    finally:
        db.close()


def update_ip_status(ip_id: int, status: str) -> MonitoredIP:
    """
    Les IPs n’ont pas de vraie pause métier. On accepte 'paused' pour compat UI,
    mais on traite 'paused' comme 'stopped' côté données (pas de hash à conserver).
    """
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
        if not item:
            raise NoResultFound(f"IP item {ip_id} not found")

        if status not in {"active", "paused", "stopped"}:
            raise ValueError(f"Unsupported IP status: {status}")

        # Normaliser: paused -> stopped pour IP
        normalized = "stopped" if status in {"paused", "stopped"} else "active"
        item.status = normalized

        if normalized == "stopped":
            item.last_status = None

        db.commit()
        db.refresh(item)
        return item
    finally:
        db.close()


def normalize_path(path: str) -> str:
    if not path:
        return path
    # Convertir backslashes → slashes
    path = path.replace("\\", "/")
    # Supprimer les espaces début/fin
    path = path.strip()
    # Remplacer doubles slashes par simples (hors protocole type http://)
    path = re.sub(r'(?<!:)//+', '/', path)
    return path

---------- END OF FILE: backend/app/services/monitoring_service.py ----------


---------- START OF FILE: backend/app/services/report_service.py ----------


---------- END OF FILE: backend/app/services/report_service.py ----------


---------- START OF FILE: backend/app/services/scan_tasks.py ----------

# import os, json, logging, hashlib
# from datetime import datetime
# from sqlalchemy.orm import Session

# from app.db.session import SessionLocal
# from app.db.models import MonitoredFile, MonitoredFolder
# from .hash_service import calculate_file_hash, calculate_folder_fingerprint, check_ip_activity

# # Configuration logging
# LOG_PATH = os.getenv("HIDS_LOG_PATH", "logs/hids.log")
# os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)

# logger = logging.getLogger("hids-scanner")
# logger.setLevel(logging.INFO)
# if not logger.handlers:
#     fh = logging.FileHandler(LOG_PATH)
#     fmt = logging.Formatter("%(asctime)s | %(levelname)s | %(message)s")
#     fh.setFormatter(fmt)
#     logger.addHandler(fh)

# def _write_alert(event_type: str, item_id: int, details: dict):
#     """Écrit une alerte dans les logs"""
#     event = {
#         "type": "alert",
#         "alert_type": event_type,
#         "item_id": item_id,
#         "timestamp": datetime.utcnow().isoformat(),
#         **details
#     }
#     logger.warning(json.dumps(event, ensure_ascii=False))

# def _write_activity(event_type: str, item_id: int, details: dict):
#     """Écrit une activité normale dans les logs"""
#     event = {
#         "type": "activity",
#         "activity_type": event_type,
#         "item_id": item_id,
#         "timestamp": datetime.utcnow().isoformat(),
#         **details
#     }
#     logger.info(json.dumps(event, ensure_ascii=False))

# def scan_file(item_id: int, path: str):
#     """Scan réel d'un fichier avec comparaison de hash"""
#     db: Session = SessionLocal()
    
#     try:
#         # Récupérer l'item depuis la base
#         item = db.query(MonitoredFile).filter(MonitoredFile.id == item_id).first()
#         if not item:
#             _write_alert("file_error", item_id, {"error": "Item not found in database", "path": path})
#             return

#         # Vérifier si le fichier existe
#         if not os.path.exists(path):
#             _write_alert("file_not_found", item_id, {"path": path})
#             # Mettre à jour le statut
#             item.current_hash = None
#             item.last_scan = datetime.utcnow()
#             db.commit()
#             return

#         # Calculer le hash actuel
#         current_hash = calculate_file_hash(path)
#         if not current_hash:
#             _write_alert("file_hash_error", item_id, {"path": path})
#             return

#         # Premier scan : établir la baseline
#         if not item.baseline_hash:
#             item.baseline_hash = current_hash
#             item.current_hash = current_hash
#             item.last_scan = datetime.utcnow()
#             db.commit()
#             _write_activity("file_baseline_established", item_id, {
#                 "path": path, 
#                 "baseline_hash": current_hash
#             })
#             return

#         # Scans suivants : comparer avec la baseline
#         item.current_hash = current_hash
#         item.last_scan = datetime.utcnow()
#         db.commit()

#         if current_hash != item.baseline_hash:
#             _write_alert("file_modified", item_id, {
#                 "path": path,
#                 "previous_hash": item.baseline_hash,
#                 "current_hash": current_hash
#             })
#         else:
#             _write_activity("file_unchanged", item_id, {"path": path})

#     except Exception as e:
#         _write_alert("file_scan_error", item_id, {"path": path, "error": str(e)})
#     finally:
#         db.close()

# def scan_folder(item_id: int, path: str):
#     """Scan réel d'un dossier"""
#     db: Session = SessionLocal()
    
#     try:
#         item = db.query(MonitoredFolder).filter(MonitoredFolder.id == item_id).first()
#         if not item:
#             _write_alert("folder_error", item_id, {"error": "Item not found in database", "path": path})
#             return

#         if not os.path.exists(path) or not os.path.isdir(path):
#             _write_alert("folder_not_found", item_id, {"path": path})
#             item.folder_hash = None
#             item.file_count = 0
#             item.last_scan = datetime.utcnow()
#             db.commit()
#             return

#         # Calculer l'empreinte du dossier
#         fingerprint = calculate_folder_fingerprint(path)
#         if not fingerprint:
#             _write_alert("folder_scan_error", item_id, {"path": path})
#             return

#         current_hash, file_count = fingerprint

#         # Premier scan
#         if not item.folder_hash:
#             item.folder_hash = current_hash
#             item.file_count = file_count
#             item.last_scan = datetime.utcnow()
#             db.commit()
#             _write_activity("folder_baseline_established", item_id, {
#                 "path": path,
#                 "baseline_hash": current_hash,
#                 "file_count": file_count
#             })
#             return

#         # Scans suivants
#         previous_file_count = item.file_count
#         item.file_count = file_count
#         item.last_scan = datetime.utcnow()
#         db.commit()

#         if current_hash != item.folder_hash:
#             _write_alert("folder_modified", item_id, {
#                 "path": path,
#                 "previous_hash": item.folder_hash,
#                 "current_hash": current_hash,
#                 "previous_file_count": previous_file_count,
#                 "current_file_count": file_count
#             })
            
#             # Mettre à jour la baseline pour les prochains scans
#             item.folder_hash = current_hash
#             db.commit()
#         else:
#             _write_activity("folder_unchanged", item_id, {
#                 "path": path, 
#                 "file_count": file_count
#             })

#     except Exception as e:
#         _write_alert("folder_scan_error", item_id, {"path": path, "error": str(e)})
#     finally:
#         db.close()

# def scan_ip(item_id: int, ip: str, hostname: str = None):
#     """Scan réel d'une IP"""
#     db: Session = SessionLocal()
    
#     try:
#         item = db.query(MonitoredIP).filter(MonitoredIP.id == item_id).first()
#         if not item:
#             _write_alert("ip_error", item_id, {"error": "Item not found in database", "ip": ip})
#             return

#         # Vérifier l'activité de l'IP
#         ip_status = check_ip_activity(ip)
        
#         # Premier scan
#         if not hasattr(item, 'last_status') or not item.last_status:
#             item.last_status = json.dumps(ip_status)
#             item.last_scan = datetime.utcnow()
#             db.commit()
#             _write_activity("ip_baseline_established", item_id, {
#                 "ip": ip,
#                 "status": ip_status
#             })
#             return

#         # Comparaison avec le statut précédent
#         previous_status = json.loads(item.last_status)
#         item.last_status = json.dumps(ip_status)
#         item.last_scan = datetime.utcnow()
#         db.commit()

#         # Détection des changements
#         if previous_status.get('is_active') != ip_status.get('is_active'):
#             _write_alert("ip_status_changed", item_id, {
#                 "ip": ip,
#                 "previous_active": previous_status.get('is_active'),
#                 "current_active": ip_status.get('is_active'),
#                 "connections": ip_status.get('connections', [])
#             })

#     except Exception as e:
#         _write_alert("ip_scan_error", item_id, {"ip": ip, "error": str(e)})
#     finally:
#         db.close()

import os, json, logging
from datetime import datetime
from sqlalchemy.orm import Session

from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredFolder, MonitoredIP
from .hash_service import calculate_file_hash, calculate_folder_fingerprint, check_ip_activity

# ───────────────────────────────────────────────
# Configuration des fichiers de logs
# ───────────────────────────────────────────────
HIDS_LOG_PATH = os.getenv("HIDS_LOG_PATH", "logs/hids.log")
ALERTS_LOG_PATH = os.getenv("HIDS_ALERTS_LOG_PATH", "logs/alerts.log")

os.makedirs(os.path.dirname(HIDS_LOG_PATH), exist_ok=True)

# Logger global (toutes activités + trace des alertes)
hids_logger = logging.getLogger("hids")
hids_logger.setLevel(logging.INFO)
if not hids_logger.handlers:
    fh = logging.FileHandler(HIDS_LOG_PATH)
    fmt = logging.Formatter("%(asctime)s | %(levelname)s | %(message)s")
    fh.setFormatter(fmt)
    hids_logger.addHandler(fh)

# Logger dédié aux alertes (fichier séparé)
alerts_logger = logging.getLogger("alerts")
alerts_logger.setLevel(logging.WARNING)
if not alerts_logger.handlers:
    fh = logging.FileHandler(ALERTS_LOG_PATH)
    fmt = logging.Formatter("%(asctime)s | %(levelname)s | %(message)s")
    fh.setFormatter(fmt)
    alerts_logger.addHandler(fh)


# ───────────────────────────────────────────────
# Helpers
# ───────────────────────────────────────────────
def _map_severity(severity: str) -> int:
    """Mappe une sévérité textuelle vers logging.*"""
    return {
        "CRITICAL": logging.CRITICAL,
        "HIGH": logging.ERROR,
        "MEDIUM": logging.WARNING,
        "LOW": logging.INFO,
        "INFO": logging.DEBUG,
    }.get(severity.upper(), logging.WARNING)


def _write_alert(event_type: str, item_id: int, severity: str, details: dict):
    """Écrit une alerte dans alerts.log (+ warning dans hids.log)."""
    event = {
        "type": "alert",
        "alert_type": event_type,
        "item_id": item_id,
        "severity": severity.upper(),
        "timestamp": datetime.utcnow().isoformat(),
        **details
    }
    line = json.dumps(event, ensure_ascii=False)

    alerts_logger.log(_map_severity(severity), line)
    hids_logger.warning(line)  # garder aussi une trace globale


def _write_activity(event_type: str, item_id: int, details: dict):
    """Écrit une activité normale dans hids.log uniquement."""
    event = {
        "type": "activity",
        "activity_type": event_type,
        "item_id": item_id,
        "timestamp": datetime.utcnow().isoformat(),
        **details
    }
    hids_logger.info(json.dumps(event, ensure_ascii=False))


# ───────────────────────────────────────────────
# Scans
# ───────────────────────────────────────────────
def scan_file(item_id: int, path: str):
    """Scan réel d'un fichier avec comparaison de hash"""
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredFile).filter(MonitoredFile.id == item_id).first()
        if not item:
            _write_alert("file_error", item_id, "HIGH", {"error": "Item not found in database", "path": path})
            return

        if not os.path.exists(path):
            _write_alert("file_not_found", item_id, "HIGH", {"path": path})
            item.current_hash = None
            item.last_scan = datetime.utcnow()
            db.commit()
            return

        current_hash = calculate_file_hash(path)
        if not current_hash:
            _write_alert("file_hash_error", item_id, "MEDIUM", {"path": path})
            return

        if not item.baseline_hash:
            item.baseline_hash = current_hash
            item.current_hash = current_hash
            item.last_scan = datetime.utcnow()
            db.commit()
            _write_activity("file_baseline_established", item_id, {
                "path": path, "baseline_hash": current_hash
            })
            return

        # Comparaison
        item.current_hash = current_hash
        item.last_scan = datetime.utcnow()
        db.commit()

        if current_hash != item.baseline_hash:
            _write_alert("file_modified", item_id, "CRITICAL", {
                "path": path,
                "previous_hash": item.baseline_hash,
                "current_hash": current_hash
            })
        else:
            _write_activity("file_unchanged", item_id, {"path": path})

    except Exception as e:
        _write_alert("file_scan_error", item_id, "CRITICAL", {"path": path, "error": str(e)})
    finally:
        db.close()


def scan_folder(item_id: int, path: str):
    """Scan réel d'un dossier"""
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredFolder).filter(MonitoredFolder.id == item_id).first()
        if not item:
            _write_alert("folder_error", item_id, "HIGH", {"error": "Item not found in database", "path": path})
            return

        if not os.path.exists(path) or not os.path.isdir(path):
            _write_alert("folder_not_found", item_id, "HIGH", {"path": path})
            item.folder_hash = None
            item.file_count = 0
            item.last_scan = datetime.utcnow()
            db.commit()
            return

        fingerprint = calculate_folder_fingerprint(path)
        if not fingerprint:
            _write_alert("folder_scan_error", item_id, "MEDIUM", {"path": path})
            return

        current_hash, file_count = fingerprint

        if not item.folder_hash:
            item.folder_hash = current_hash
            item.file_count = file_count
            item.last_scan = datetime.utcnow()
            db.commit()
            _write_activity("folder_baseline_established", item_id, {
                "path": path, "baseline_hash": current_hash, "file_count": file_count
            })
            return

        previous_file_count = item.file_count
        item.file_count = file_count
        item.last_scan = datetime.utcnow()
        db.commit()

        if current_hash != item.folder_hash:
            _write_alert("folder_modified", item_id, "HIGH", {
                "path": path,
                "previous_hash": item.folder_hash,
                "current_hash": current_hash,
                "previous_file_count": previous_file_count,
                "current_file_count": file_count
            })
            item.folder_hash = current_hash
            db.commit()
        else:
            _write_activity("folder_unchanged", item_id, {"path": path, "file_count": file_count})

    except Exception as e:
        _write_alert("folder_scan_error", item_id, "CRITICAL", {"path": path, "error": str(e)})
    finally:
        db.close()


def scan_ip(item_id: int, ip: str, hostname: str = None):
    """Scan réel d'une IP"""
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredIP).filter(MonitoredIP.id == item_id).first()
        if not item:
            _write_alert("ip_error", item_id, "HIGH", {"error": "Item not found in database", "ip": ip})
            return

        ip_status = check_ip_activity(ip)

        if not hasattr(item, 'last_status') or not item.last_status:
            item.last_status = json.dumps(ip_status)
            item.last_scan = datetime.utcnow()
            db.commit()
            _write_activity("ip_baseline_established", item_id, {"ip": ip, "status": ip_status})
            return

        previous_status = json.loads(item.last_status)
        item.last_status = json.dumps(ip_status)
        item.last_scan = datetime.utcnow()
        db.commit()

        if previous_status.get('is_active') != ip_status.get('is_active'):
            _write_alert("ip_status_changed", item_id, "MEDIUM", {
                "ip": ip,
                "previous_active": previous_status.get('is_active'),
                "current_active": ip_status.get('is_active'),
                "connections": ip_status.get('connections', [])
            })

    except Exception as e:
        _write_alert("ip_scan_error", item_id, "CRITICAL", {"ip": ip, "error": str(e)})
    finally:
        db.close()

---------- END OF FILE: backend/app/services/scan_tasks.py ----------


---------- START OF FILE: backend/app/services/hash_service.py ----------

# import hashlib
# import os
# import psutil
# from datetime import datetime
# from typing import Optional, Tuple

# def calculate_file_hash(file_path: str) -> Optional[str]:
#     """Calcule le SHA256 d'un fichier"""
#     try:
#         if not os.path.exists(file_path):
#             return None
            
#         hasher = hashlib.sha256()
#         with open(file_path, 'rb') as f:
#             for chunk in iter(lambda: f.read(4096), b""):
#                 hasher.update(chunk)
#         return hasher.hexdigest()
#     except Exception:
#         return None

# def calculate_folder_fingerprint(folder_path: str) -> Optional[Tuple[str, int]]:
#     """Calcule une empreinte du dossier (hash + nombre de fichiers)"""
#     try:
#         if not os.path.exists(folder_path) or not os.path.isdir(folder_path):
#             return None
            
#         file_hashes = []
#         file_count = 0
        
#         for root, dirs, files in os.walk(folder_path):
#             for file in files:
#                 file_path = os.path.join(root, file)
#                 file_hash = calculate_file_hash(file_path)
#                 if file_hash:
#                     file_hashes.append(file_hash)
#                 file_count += 1
        
#         if not file_hashes:
#             return ("empty_folder", 0)
            
#         # Créer un hash unique pour le dossier basé sur tous les fichiers
#         combined_hash = hashlib.sha256(''.join(sorted(file_hashes)).encode()).hexdigest()
#         return (combined_hash, file_count)
#     except Exception:
#         return None

# def check_ip_activity(ip: str) -> dict:
#     """Vérifie l'activité d'une IP via les connexions réseau"""
#     try:
#         connections = psutil.net_connections()
#         ip_connections = []
        
#         for conn in connections:
#             if conn.raddr and conn.raddr.ip == ip:
#                 ip_connections.append({
#                     'status': conn.status,
#                     'local_port': conn.laddr.port,
#                     'remote_port': conn.raddr.port
#                 })
        
#         return {
#             'ip': ip,
#             'is_active': len(ip_connections) > 0,
#             'connections': ip_connections,
#             'timestamp': datetime.utcnow().isoformat()
#         }
#     except Exception as e:
#         return {'ip': ip, 'is_active': False, 'error': str(e)}

import hashlib
import os
import subprocess
from datetime import datetime
from typing import Optional, Tuple

def calculate_file_hash(file_path: str) -> Optional[str]:
    """Calcule le SHA256 d'un fichier"""
    try:
        if not os.path.exists(file_path):
            return None
            
        hasher = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hasher.update(chunk)
        return hasher.hexdigest()
    except Exception:
        return None

def calculate_folder_fingerprint(folder_path: str) -> Optional[Tuple[str, int]]:
    """Calcule une empreinte du dossier (hash + nombre de fichiers)"""
    try:
        if not os.path.exists(folder_path) or not os.path.isdir(folder_path):
            return None
            
        file_hashes = []
        file_count = 0
        
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                file_hash = calculate_file_hash(file_path)
                if file_hash:
                    file_hashes.append(file_hash)
                file_count += 1
        
        if not file_hashes:
            return ("empty_folder", 0)
            
        # Créer un hash unique pour le dossier basé sur tous les fichiers
        combined_hash = hashlib.sha256(''.join(sorted(file_hashes)).encode()).hexdigest()
        return (combined_hash, file_count)
    except Exception:
        return None

def check_ip_activity(ip: str) -> dict:
    """
    Surveillance IP alternative sans psutil
    Utilise les commandes système pour vérifier les connexions
    """
    try:
        # Méthode 1: Utiliser netstat (Linux/Windows)
        try:
            result = subprocess.run(
                ["netstat", "-an"], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            is_connected = ip in result.stdout
            return {
                'ip': ip,
                'is_active': is_connected,
                'method': 'netstat',
                'timestamp': datetime.utcnow().isoformat()
            }
        except Exception:
            pass
            
        # Méthode 2: Utiliser ping comme fallback
        try:
            # Sur Windows
            param = "-n" if os.name == "nt" else "-c"
            result = subprocess.run(
                ["ping", param, "1", ip], 
                capture_output=True, 
                text=True, 
                timeout=5
            )
            is_connected = result.returncode == 0
            return {
                'ip': ip,
                'is_active': is_connected,
                'method': 'ping',
                'timestamp': datetime.utcnow().isoformat()
            }
        except Exception:
            pass
            
        # Fallback si tout échoue
        return {
            'ip': ip,
            'is_active': False,
            'method': 'fallback',
            'error': 'Unable to determine IP status',
            'timestamp': datetime.utcnow().isoformat()
        }
        
    except Exception as e:
        return {
            'ip': ip, 
            'is_active': False, 
            'error': str(e),
            'timestamp': datetime.utcnow().isoformat()
        }
---------- END OF FILE: backend/app/services/hash_service.py ----------


---------- START OF FILE: backend/app/main.py ----------

from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from app.core.logging import logger
from app.core.config import settings
from app.db.base import Base
from app.db.session import engine as db_engine
Base.metadata.create_all(bind=db_engine)

from app.core.scheduler import start_scheduler, shutdown_scheduler, add_interval_job, FREQ_SECONDS
from app.services.scan_tasks import scan_file, scan_folder, scan_ip
from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredFolder, MonitoredIP

from app.api.status import router as status_router
from app.api.auth import router as auth_router
from app.api.users import router as users_router
from app.api.monitoring import router as monitoring_router
from app.api.metrics import router as metrics_router
from app.api.reports import router as reports_router
from app.api import engine as engine_routes
from app.api import fs 
# Importation du nouveau routeur unifié pour les logs
from app.api import logs

logger.info(f"Starting {settings.APP_NAME}... (version: {settings.VERSION})")


app = FastAPI(
    title=settings.APP_NAME,
    version=settings.VERSION,
    docs_url="/docs",
    redoc_url="/redoc"
)

# --- CORS ---
origins = [o.strip() for o in settings.ALLOWED_ORIGINS.split(",") if o.strip()]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# @app.on_event("startup")
# def on_startup():
#     """
#     Fonction de démarrage de l'application.
#     """
#     logger.info("Creating database tables (if not exist)...")
    
#     Base.metadata.create_all(bind=db_engine)
#     logger.info("Database ready.")
    
#     start_scheduler()
#     db = SessionLocal()
#     try:
#         for f in db.query(MonitoredFile).filter(MonitoredFile.status == "active").all():
#             sec = FREQ_SECONDS.get(getattr(f, "frequency", "hourly"), 3600)
#             add_interval_job("file", f.id, sec, scan_file, item_id=f.id, path=f.path)
#         for d in db.query(MonitoredFolder).filter(MonitoredFolder.status == "active").all():
#             sec = FREQ_SECONDS.get(getattr(d, "frequency", "hourly"), 3600)
#             add_interval_job("folder", d.id, sec, scan_folder, item_id=d.id, path=d.path)
#         for i in db.query(MonitoredIP).filter(MonitoredIP.status == "active").all():
#             sec = FREQ_SECONDS.get(getattr(i, "frequency", "hourly"), 3600)
#             add_interval_job("ip", i.id, sec, scan_ip, item_id=i.id, ip=i.ip, hostname=i.hostname)
#     finally:
#         db.close()

@app.on_event("startup")
def on_startup():
    """
    Fonction de démarrage de l'application.
    """
    logger.info("Creating database tables (if not exist)...")
    Base.metadata.create_all(bind=db_engine)
    logger.info("Database ready.")
    
    # Démarrer le scheduler d'abord
    start_scheduler()
    logger.info("Scheduler started.")
    
    # Ensuite planifier les jobs
    db = SessionLocal()
    try:
        # Vérifier que le scheduler est actif
        from app.core.scheduler import get_scheduler
        scheduler = get_scheduler()
        if not scheduler.running:
            logger.error("Scheduler is not running!")
            return
            
        logger.info("Scheduling existing monitoring jobs...")
        
        for f in db.query(MonitoredFile).filter(MonitoredFile.status == "active").all():
            sec = FREQ_SECONDS.get(getattr(f, "frequency", "hourly"), 3600)
            add_interval_job("file", f.id, sec, scan_file, item_id=f.id, path=f.path)
            logger.info(f"Scheduled file monitoring: {f.path} (every {sec}s)")
            
        for d in db.query(MonitoredFolder).filter(MonitoredFolder.status == "active").all():
            sec = FREQ_SECONDS.get(getattr(d, "frequency", "hourly"), 3600)
            add_interval_job("folder", d.id, sec, scan_folder, item_id=d.id, path=d.path)
            logger.info(f"Scheduled folder monitoring: {d.path} (every {sec}s)")
            
        for i in db.query(MonitoredIP).filter(MonitoredIP.status == "active").all():
            sec = FREQ_SECONDS.get(getattr(i, "frequency", "hourly"), 3600)
            add_interval_job("ip", i.id, sec, scan_ip, item_id=i.id, ip=i.ip, hostname=i.hostname)
            logger.info(f"Scheduled IP monitoring: {i.ip} (every {sec}s)")
            
        logger.info("All monitoring jobs scheduled successfully.")
        
    except Exception as e:
        logger.error(f"Error during startup job scheduling: {e}")
    finally:
        db.close()


@app.on_event("shutdown")
def on_shutdown():
    """
    Fonction d'arrêt de l'application.
    """
    logger.info("Shutting down application...")
    
    shutdown_scheduler()
    
app.include_router(status_router, prefix="/api")
app.include_router(auth_router, prefix="/api")
app.include_router(users_router)
app.include_router(monitoring_router)
# Inclus le nouveau routeur unifié pour les logs
app.include_router(logs.router, prefix="/api")
app.include_router(metrics_router)
app.include_router(reports_router)
app.include_router(engine_routes.router)
app.include_router(fs.router)
---------- END OF FILE: backend/app/main.py ----------


---------- START OF FILE: hids-web/src/components/EngineCard.jsx ----------

// export default function EngineCard({ title, counts = {}, onAction }) {
//     const { total = 0, active = 0, paused = 0 } = counts;
//     const status =
//         active > 0 ? "running" : total === 0 ? "stopped" : paused === total ? "paused" : "stopped";

//     const tone =
//         status === "running" ? "success" : status === "paused" ? "warn" : "danger";
//     const dot =
//         tone === "success" ? "bg-success" : tone === "warn" ? "bg-warn" : "bg-danger";

//     // Boutons conditionnels
//     const actions =
//         status === "running"
//         ? [
//             { key: "pause-all", label: "Pause" },
//             { key: "stop-all", label: "Stop" },
//             ]
//         : status === "paused"
//         ? [
//             { key: "resume-all", label: "Resume" },
//             { key: "stop-all", label: "Stop" },
//             ]
//         : /* stopped */
//             [{ key: "resume-all", label: "Start" }];

//     return (
//         <div className="card p-4">
//         {/* Titre plus mis en avant */}
//         <div className="text-xs text-muted">{title}</div>

//         <div className="mt-1 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
//             {/* Etat */}
//             <div>
//             <div className="text-2xl font-semibold flex items-center gap-2 leading-none">
//                 <span className={`inline-block w-2 h-2 rounded-full ${dot}`} />
//                 {status.charAt(0).toUpperCase() + status.slice(1)}
//             </div>
//             <div className="text-xs text-muted mt-1">
//                 {active}/{total} active · {paused} paused
//             </div>
//             </div>

//             {/* Actions (wrap sur petits écrans) */}
//             <div className="flex flex-wrap gap-2">
//             {actions.map((a) => (
//                 <button
//                 key={a.key}
//                 className="btn px-3 py-1.5 text-sm"
//                 onClick={() => onAction(a.key)}
//                 >
//                 {a.label}
//                 </button>
//             ))}
//             </div>
//         </div>
//         </div>
//     );
// }

import { useState } from "react";


export default function EngineCard({ title, counts = {}, onAction, disabled = false }) {
    const { total = 0, active = 0, paused = 0 } = counts;
    const [isLoading, setIsLoading] = useState(false);
    
    const status = active > 0 ? "running" : total === 0 ? "stopped" : paused === total ? "paused" : "stopped";

    // const tone = status === "running" ? "success" : status === "paused" ? "warn" : "danger";
    // const dot = tone === "success" ? "bg-success" : tone === "warn" ? "bg-warn" : "bg-danger";

    const dot =
        status === "running"
            ? "bg-green-500"   
            : status === "paused"
            ? "bg-orange-300"  
            : "bg-red-700";    


    // Boutons conditionnels
    const actions = status === "running"
        ? [{ key: "pause-all", label: "Pause" }, { key: "stop-all", label: "Stop" }]
        : status === "paused"
        ? [{ key: "resume-all", label: "Resume" }, { key: "stop-all", label: "Stop" }]
        : [{ key: "resume-all", label: "Start" }];

    const handleAction = async (actionKey) => {
        if (disabled || isLoading) return;
        
        setIsLoading(true);
        try {
            await onAction(actionKey);
        } catch (error) {
            console.error("Action failed:", error);
        } finally {
            // Reset après un délai pour voir la confirmation
            setTimeout(() => setIsLoading(false), 1000);
        }
    };

    return (
        <div className={`card p-4 transition-all duration-200 ${isLoading ? 'opacity-70' : ''}`}>
            <div className="text-xs text-muted">{title}</div>

            <div className="mt-1 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
                {/* Etat */}
                <div>
                    <div className="text-2xl font-semibold flex items-center gap-2 leading-none">
                        <span className={`inline-block w-2 h-2 rounded-full ${dot} ${isLoading ? 'animate-pulse' : ''}`} />
                        {isLoading ? "Updating..." : status.charAt(0).toUpperCase() + status.slice(1)}
                    </div>
                    <div className="text-xs text-muted mt-1">
                        {active}/{total} active · {paused} paused
                    </div>
                </div>

                {/* Actions */}
                {/* <div className="flex flex-wrap gap-2">
                    {actions.map((a) => (
                        <button
                            key={a.key}
                            className={`btn px-3 py-1.5 text-sm transition-all ${
                                disabled || isLoading ? 'opacity-50 cursor-not-allowed' : 'hover:scale-105'
                            }`}
                            onClick={() => handleAction(a.key)}
                            disabled={disabled || isLoading}
                        >
                            {isLoading ? "..." : a.label}
                        </button>
                    ))}
                </div> */}
                {/* Actions */}
                <div className="flex flex-row gap-3 flex-nowrap">
                {actions.map((a) => (
                    <button
                    key={a.key}
                    className={`px-4 py-2 text-sm rounded-xl border border-white/10 bg-panel2 
                                transition-all duration-200
                                ${disabled || isLoading 
                                    ? "opacity-50 cursor-not-allowed" 
                                    : "hover:scale-105 hover:bg-panel hover:shadow-lg"
                                }`}
                    onClick={() => handleAction(a.key)}
                    disabled={disabled || isLoading}
                    >
                    {isLoading ? "..." : a.label}
                    </button>
                ))}
                </div>

            </div>
        </div>
    );
}
---------- END OF FILE: hids-web/src/components/EngineCard.jsx ----------


---------- START OF FILE: hids-web/src/context/AuthProvider.jsx ----------

// Fichier : hids-web/src/context/AuthProvider.jsx

import { createContext, useContext, useEffect, useMemo, useState } from 'react'
import { api } from '../lib/api'
import { jwtDecode } from 'jwt-decode'; // Assurez-vous d'installer ce paquet

const AuthCtx = createContext(null)
export const useAuth = () => useContext(AuthCtx)

export function AuthProvider({ children }) {
    const [token, setToken] = useState(() => localStorage.getItem('hids.token') || '')
    const [user, setUser] = useState(null); // Nouvel état pour les informations utilisateur
    const [loading, setLoading] = useState(false)
    const [error, setError] = useState('')

    // Effet pour décoder le token lorsque qu'il change
    useEffect(() => {
        if (token) {
            try {
                // Décoder le token et stocker les informations utilisateur (y compris is_admin)
                const decodedUser = jwtDecode(token);
                setUser(decodedUser);
            } catch (e) {
                console.error("Failed to decode token", e);
                setUser(null);
                setToken('');
                localStorage.removeItem('hids.token');
            }
        } else {
            setUser(null);
        }
    }, [token]);

    // // Quand un token existe, on demande le profil au backend
    // useEffect(() => {
    //     let cancelled = false;
    //     (async () => {
    //         if (!token) { setUser(null); return; }
    //         try {
    //         const me = await api.me(token);   // { id, username, email, is_admin, ... }
    //         if (!cancelled) setUser(me);
    //         } catch (e) {
    //         console.error("Failed to fetch /users/me", e);
    //         if (!cancelled) {
    //             setUser(null);
    //             setToken('');
    //             localStorage.removeItem('hids.token');
    //         }
    //         }
    //     })();
    //     return () => { cancelled = true; };
    //     }, [token]);

    const login = async (username, password) => {
        setLoading(true); setError('')
        try {
            const data = await api.login(username, password)
            setToken(data.access_token)
            localStorage.setItem('hids.token', data.access_token)
            return true
        } catch (e) {
            setError(e.message); return false
        } finally { setLoading(false) }
    }

    const logout = () => {
        setToken('')
        setUser(null); // Réinitialisez l'utilisateur
        localStorage.removeItem('hids.token')
    }

    // Le contexte expose maintenant les informations de l'utilisateur
    const value = useMemo(()=>({ token, user, login, logout, loading, error }), [token, user, loading, error])
    return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>
}
---------- END OF FILE: hids-web/src/context/AuthProvider.jsx ----------


---------- START OF FILE: hids-web/src/pages/AlertsLogs.jsx ----------

// src/pages/AlertsLogs.jsx

import { useEffect, useState } from "react";
import { api } from "../lib/api";
import { useAuth } from "../context/AuthProvider";
import { useNavigate } from "react-router-dom";

const PAGE_SIZE = 15;

// ── UI bits ────────────────────────────────────────────────────────────────────
function Badge({ children, className = "" }) {
  return (
    <span className={`px-2 py-1 rounded-full text-xs font-bold inline-flex items-center ${className}`}>
      {children}
    </span>
  );
}

// Composant LevelBadge mis à jour pour correspondre aux couleurs douces
const LevelBadge = ({ level }) => {
  const L = String(level || "").toUpperCase();
  const cls =
    L === "CRITICAL" ? "bg-red-500/30 text-white" :
    L === "HIGH"     ? "bg-red-500/20 text-red-300" :
    L === "MEDIUM"   ? "bg-yellow-500/20 text-yellow-300" :
    L === "LOW"      ? "bg-sky-500/20 text-sky-300" :
    L === "WARNING"  ? "bg-yellow-500/20 text-yellow-300" :
    L === "INFO"     ? "bg-green-500/20 text-green-300" :
                    "bg-white/5 text-muted";
  return <Badge className={cls}>{L || "—"}</Badge>;
};

function TableShell({ headers, children }) {
  return (
    <div className="card p-0 overflow-hidden">
      <table className="w-full text-sm">
        <thead className="bg-white/5 text-muted sticky top-0">
          <tr>
            {headers.map((h, i) => (
              <th key={i} className={`px-4 py-3 ${i === headers.length - 1 ? "text-right" : "text-left"}`}>{h}</th>
            ))}
          </tr>
        </thead>
        <tbody>{children}</tbody>
      </table>
    </div>
  );
}

function Pager({ page, pageCount, onPage }) {
  return (
    <div className="flex items-center justify-between gap-2">
      <div className="text-xs text-muted">Page {Math.min(page, pageCount) || 1} / {pageCount || 1}</div>
      <div className="flex gap-2">
        <button
          className="px-3 py-1.5 rounded-md border border-white/10 bg-panel/50 disabled:opacity-50"
          onClick={() => onPage(Math.max(1, page - 1))}
          disabled={page <= 1}
        >← Prev</button>
        <button
          className="px-3 py-1.5 rounded-md border border-white/10 bg-panel/50 disabled:opacity-50"
          onClick={() => onPage(Math.min(pageCount || 1, page + 1))}
          disabled={page >= (pageCount || 1)}
        >Next →</button>
      </div>
    </div>
  );
}

// ── Page ──────────────────────────────────────────────────────────────────────
export default function AlertsLogs() {
  const { token, user } = useAuth(); // on récupère l'objet user
  const navigate = useNavigate();

  const [tab, setTab] = useState("alerts"); // "alerts" | "activity"
  const [page, setPage] = useState(1);

  // filtres
  const [level, setLevel] = useState("");
  const [contains, setContains] = useState("");

  // données
  const [items, setItems] = useState([]);
  const [pageCount, setPageCount] = useState(1);
  const [loading, setLoading] = useState(false);

  // reset pagination si on change d’onglet
  useEffect(() => {
    setPage(1);
    setLevel("");
    setContains("");
  }, [tab]);

  // charge une page depuis le backend
  useEffect(() => {
    // Si le token n'est pas encore disponible, on ne fait pas l'appel
    if (!token) {
        return;
    }

    let stopped = false;
    (async () => {
      setLoading(true);
      try {
        const r = await api.listHidsLog(token, {
          type: tab, page, limit: PAGE_SIZE, level, contains
        });
        if (stopped) return;
        setItems(r.lines || []);
        setPageCount(r.page_count || 1);
      } catch (e) {
        console.error("Failed to fetch logs:", e);
        if (!stopped) {
          setItems([]);
          setPageCount(1);
        }
      } finally {
        if (!stopped) setLoading(false);
      }
    })();
    return () => { stopped = true; };
  }, [token, tab, page, level, contains]);

  const onClear = async () => {
    // On utilise une boîte de dialogue personnalisée au lieu de window.confirm
    // const confirmed = await showCustomConfirmDialog("⚠️ This will permanently clear logs. Continue?");
    if (!window.confirm(`⚠️ This will permanently clear ${tab} logs. Continue?`)) return;
    try {
      await api.clearHidsLog(token, tab);
      setPage(1);
    } catch (e) {
      // On utilise une boîte de dialogue personnalisée au lieu de window.alert
      // showCustomAlertDialog("Clear failed: " + (e?.body?.detail || e.message));
      window.alert("Clear failed: " + (e?.body?.detail || e.message));
    }
  };

  const headers = ["Date", "Time", "Level", "Source", "Message"];

  // Déterminer les niveaux de filtre en fonction de l'onglet actif
  const levels = tab === "alerts"
    ? ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"]
    : ["INFO", "WARNING", "ERROR"];

  const isAdmin = user?.is_admin; // Vérifie si l'utilisateur est admin

  return (
    <div className="space-y-6">
      {/* Tabs + Clear */}
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          {["alerts", "activity"].map(t => (
            <button
              key={t}
              onClick={() => setTab(t)}
              className={`px-3 py-1.5 rounded-md border capitalize ${tab===t ? "bg-panel2 border-white/10" : "bg-panel/50 border-white/5"}`}
            >{t}</button>
          ))}
        </div>

        <button
          onClick={onClear}
          disabled={!isAdmin} // Bouton désactivé si l'utilisateur n'est pas admin
          className="px-3 py-1.5 rounded-md border border-white/10 text-white disabled:opacity-50 disabled:cursor-not-allowed"
          title={`Clear ${tab} logs (admin only server-side)`}
          style={{
            background: isAdmin ? "linear-gradient(90deg, #d32f2f, #ef5350)" : "rgba(255, 255, 255, 0.05)",
            borderColor: isAdmin ? "#ef5350" : "rgba(255, 255, 255, 0.1)",
            color: isAdmin ? "white" : "rgba(255, 255, 255, 0.5)",
          }}
        >
          Clear logs
        </button>
      </div>

      {/* Filtres */}
      <div className="card p-3">
        <div className="flex flex-wrap gap-3">
          <select
            className="bg-panel2 border border-white/10 rounded-md text-sm px-2 py-1"
            value={level}
            onChange={e=>{ setLevel(e.target.value); setPage(1); }}
          >
            <option value="">Level: any</option>
            {levels.map(l => (
              <option key={l} value={l}>{l}</option>
            ))}
          </select>

          <input
            className="bg-panel2 border border-white/10 rounded-md text-sm px-2 py-1"
            placeholder="Search message…"
            value={contains}
            onChange={e=>{ setContains(e.target.value); setPage(1); }}
          />
        </div>
      </div>

      {/* Tableau */}
      <TableShell headers={headers}>
        {loading && (<tr><td colSpan={headers.length} className="px-4 py-6 text-muted">Loading…</td></tr>)}
        {!loading && items.length === 0 && (
          <tr><td colSpan={headers.length} className="px-4 py-6 text-muted">No log lines</td></tr>
        )}
        {!loading && items.map((ln, i)=>(
          <tr key={`${ln.ts}-${i}`} className="border-t border-white/5">
            <td className="px-4 py-2">{ln.ts ? new Date(ln.ts).toLocaleDateString() : "—"}</td>
            <td className="px-4 py-2 text-muted">{ln.ts ? new Date(ln.ts).toLocaleTimeString() : "—"}</td>
            <td className="px-4 py-2"><LevelBadge level={ln.level} /></td>
            <td className="px-4 py-2">{ln.source || "—"}</td>
            <td className="px-4 py-2 text-right font-mono">{ln.msg || "—"}</td>
          </tr>
        ))}
      </TableShell>

      <Pager page={page} pageCount={pageCount} onPage={setPage}/>
    </div>
  );
}

---------- END OF FILE: hids-web/src/pages/AlertsLogs.jsx ----------


---------- START OF FILE: hids-web/src/pages/Reports.jsx ----------

// src/pages/Reports.jsx
import { useEffect, useMemo, useState } from "react";
import { useAuth } from "../context/AuthProvider";
import { api } from "../lib/api";
import { PieChart, Pie, Cell, ResponsiveContainer } from "recharts";


const COLORS = ["#10b981", "#3b82f6", "#f59e0b"];

function SummaryChart({ files, folders, ips }) {
    const data = [
        { name: "Files", value: files },
        { name: "Folders", value: folders },
        { name: "IPs", value: ips },
    ];
    return (
        <ResponsiveContainer width="100%" height={180}>
        <PieChart>
            <Pie
            data={data}
            cx="50%" cy="50%"
            outerRadius={60} // au lieu de 80
            dataKey="value"
            >
            {data.map((entry, index) => (
                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
            ))}
            </Pie>
        </PieChart>
        </ResponsiveContainer>
    );
}


function Pill({ children, tone = "muted" }) {
    const map = {
        muted: "bg-white/5 text-muted",
        ok: "bg-emerald-500/20 text-emerald-300",  
        warn: "bg-amber-500/20 text-amber-300",    
        danger: "bg-red-500/20 text-red-300",      
    };
    return (
        <span className={`px-2 py-0.5 rounded-full text-xs border border-white/10 ${map[tone] || map.muted}`}>
            {children}
        </span>
    );
}


function Card({ title, children, right = null, className = "" }) {
    return (
        <div className={`card p-0 overflow-hidden ${className}`}>
        <div className="flex items-center justify-between px-4 py-3 border-b border-white/10">
            <div className="text-sm text-muted">{title}</div>
            {right}
        </div>
        <div className="p-4">{children}</div>
        </div>
    );
}

function Table({ head, children, className = "" }) {
    return (
        <div className={`rounded-xl overflow-auto scrollbeauty ${className}`}>
        <table className="w-full text-sm">
            <thead className="bg-white/5 text-muted sticky top-0 z-10">
            <tr>
                {head.map((h, i) => (
                <th key={i} className="px-4 py-3 text-left">{h}</th>
                ))}
            </tr>
            </thead>
            <tbody className="[&>tr]:border-t [&>tr]:border-white/5">{children}</tbody>
        </table>
        </div>
    );
}

export default function Reports() {
    const { token } = useAuth();
    const [report, setReport] = useState(null);
    const [tab, setTab] = useState("summary");

    useEffect(() => {
        (async () => {
        const r = await api.reports(token);
        setReport(r);
        })().catch(console.error);
    }, [token]);

    const inv = useMemo(() => {
        const r = report || {};
        const inv = r.inventory || {};
        return {
        files: inv.files || [],
        folders: inv.folders || [],
        ips: inv.ips || [],
        monitored: r.metrics?.monitored || { files: 0, folders: 0, ips: 0, total: 0 },
        scheduler: r.metrics?.scheduler || { file: 0, folder: 0, ip: 0, total: 0 },
        title: r.report?.title || "HIDS-Web JSON Report",
        version: r.report?.version || "—",
        generatedAt: r.report?.generatedAt || new Date().toISOString(),
        };
    }, [report]);

    const download = () => {
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `hids-report-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
    };

    if (!report) return <div>Loading…</div>;

    return (
        <div className="space-y-4 mt-0">
            <div className="flex items-center justify-between mb-7">
                <h1 className="text-2xl font-semibold">Reports</h1>
                <button className="btn " onClick={download}>Export JSON</button>
            </div>

        {/* Split layout: 30% / 70% with reduced top margin */}
        <div className="grid gap-4 lg:grid-cols-[30%_1fr] mt-2">
            {/* Left: raw JSON with pretty scrollbar */}
            <div className="card p-0 overflow-hidden max-h-[75vh]  from-panel via-panel2 to-sky-950">
                    <div className="px-4 py-3   text-muted ">Raw JSON</div>
                    <pre className="p-4 text-sm max-h-[70vh] overflow-auto scrollbeauty text-emerald-200 bg-black/60 rounded-b-xl">
                        {JSON.stringify(report, null, 2)}
                    </pre>
            </div>

            {/* Right: visual with tabs */}
            <div className="space-y-4 ">
                {/* Tabs */}
                <div className="card p-0 overflow-hidden h-[75vh] flex flex-col">
                    <div className="px-4 py-3 border-b border-white/10 flex items-center justify-between">
                    <div className="flex gap-2">
                        {["summary","files","folders","ips"].map(t => (
                        <button
                            key={t}
                            onClick={() => setTab(t)}
                            className={`capitalize px-3 py-1.5 rounded-md border
                            ${tab===t ? "bg-panel2 border-white/10" : "bg-panel/50 border-white/5"}`}
                        >
                            {t}
                        </button>
                        ))}
                    </div>
                    <Pill tone="info">Version {inv.version}</Pill>
                    </div>

                    {/* Tab content (scrollable panel) */}
                    <div className="p-4 max-h-[72vh] overflow-auto scrollbeauty">
                    
                    {/* {tab === "summary" && (
                        <div className="grid md:grid-cols-2 xl:grid-cols-4 gap-4 h-full">
                            <Card title="Entities Monitored" className="bg-emerald-500/5">
                                <div className="text-2xl font-semibold text-white">{inv.monitored.total}</div>
                                <div className="text-sm text-muted">
                                    {inv.monitored.files} files · {inv.monitored.folders} folders · {inv.monitored.ips} IPs
                                </div>
                            </Card>

                            <Card title="Schedulers (total)" className="bg-sky-500/5">
                                <div className="text-2xl font-semibold text-white">{inv.scheduler.total}</div>
                                <div className="text-sm text-muted">
                                    file {inv.scheduler.file} · folder {inv.scheduler.folder} · ip {inv.scheduler.ip}
                                </div>
                            </Card>

                            <Card title={inv.title} className="bg-white/5">
                                <div className="text-lg font-semibold text-white">HIDS-Web</div>
                                <div className="text-xs text-muted">Report title</div>
                            </Card>

                            <Card title="Generated at" className="bg-amber-500/5">
                                <div className="text-lg font-semibold text-white">
                                    {new Date(inv.generatedAt).toLocaleDateString()}
                                </div>
                                <div className="text-xs text-muted">
                                    {new Date(inv.generatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" })}
                                </div>
                            </Card>
                            <Card title="Distribution">
                                <SummaryChart
                                    files={inv.monitored.files}
                                    folders={inv.monitored.folders}
                                    ips={inv.monitored.ips}
                                />
                            </Card>

                        </div>
                        
                    )} */}

                    {tab === "summary" && (
                        <div className="grid md:grid-cols-3 gap-6 h-full">
                            <Card title={inv.title} className="bg-white/5">
                                <div className="text-2xl font-semibold text-white">HIDS-Web</div>
                                <div className="text-sm text-muted mt-1">Report title</div>
                            </Card>

                            <Card title="Generated at" className="bg-amber-500/5">
                                <div className="text-2xl font-semibold text-white">
                                    {new Date(inv.generatedAt).toLocaleDateString()}
                                </div>
                                <div className="text-sm text-muted">
                                    {new Date(inv.generatedAt).toLocaleTimeString([], {
                                    hour: "2-digit",
                                    minute: "2-digit",
                                    second: "2-digit"
                                    })}
                                </div>
                            </Card>

                            <Card title="Entities Monitored" className="bg-emerald-500/5">
                            <div className="text-4xl font-bold text-white">{inv.monitored.total}</div>
                            <div className="text-base text-muted mt-2">
                                {inv.monitored.files} files · {inv.monitored.folders} folders · {inv.monitored.ips} IPs
                            </div>
                            </Card>

                            <Card title="Schedulers (total)" className="bg-sky-500/5">
                            <div className="text-4xl font-bold text-white">{inv.scheduler.total}</div>
                            <div className="text-base text-muted mt-2">
                                file {inv.scheduler.file} · folder {inv.scheduler.folder} · ip {inv.scheduler.ip}
                            </div>
                            </Card>

                            

                            {/* Graphique centré en bas et plus grand */}
                            <div className="md:col-span-2 flex justify-center">
                                <Card title="Distribution" className="w-full max-w-md mx-auto">
                                    <SummaryChart
                                    files={inv.monitored.files}
                                    folders={inv.monitored.folders}
                                    ips={inv.monitored.ips}
                                    />
                                </Card>
                            </div>
                        </div>
                        )}


                    {tab === "files" && (
                        <Table head={["ID","Path","Frequency","Status"]}>
                        {inv.files.map(f => (
                            <tr key={`f-${f.id}`}>
                            <td className="px-4 py-2">{f.id}</td>
                            <td className="px-4 py-2 text-white">{f.path}</td>
                            <td className="px-4 py-2"><Pill tone="info">{f.frequency}</Pill></td>
                            <td className="px-4 py-2">
                                <Pill tone={
                                    f.status === "active" ? "ok" :
                                    f.status === "paused" ? "warn" :
                                    "danger"
                                }>
                                    {f.status}
                                </Pill>
                            </td>
                            </tr>
                        ))}
                        {inv.files.length === 0 && (
                            <tr><td className="px-4 py-2 text-muted" colSpan={4}>No files in inventory.</td></tr>
                        )}
                        </Table>
                    )}

                    {tab === "folders" && (
                        <Table head={["ID","Path","Frequency","Status"]}>
                        {inv.folders.map(f => (
                            <tr key={`d-${f.id}`}>
                            <td className="px-4 py-2">{f.id}</td>
                            <td className="px-4 py-2 text-white">{f.path}</td>
                            <td className="px-4 py-2"><Pill tone="info">{f.frequency}</Pill></td>
                            <td className="px-4 py-2"><Pill tone="ok">{f.status}</Pill></td>
                            </tr>
                        ))}
                        {inv.folders.length === 0 && (
                            <tr><td className="px-4 py-2 text-muted" colSpan={4}>No folders in inventory.</td></tr>
                        )}
                        </Table>
                    )}

                    {tab === "ips" && (
                        <Table head={["ID","IP","Hostname","Frequency","Status"]}>
                        {inv.ips.map(ip => (
                            <tr key={`ip-${ip.id}`}>
                            <td className="px-4 py-2">{ip.id}</td>
                            <td className="px-4 py-2 text-white">{ip.ip}</td>
                            <td className="px-4 py-2">{ip.hostname || "—"}</td>
                            <td className="px-4 py-2"><Pill tone="info">{ip.frequency}</Pill></td>
                            <td className="px-4 py-2">
                                <Pill tone={
                                    ip.status === "active" ? "ok" :
                                    ip.status === "paused" ? "warn" :
                                    "danger"
                                }>
                                    {ip.status}
                                </Pill>
                            </td>

                            </tr>
                        ))}
                        {inv.ips.length === 0 && (
                            <tr><td className="px-4 py-2 text-muted" colSpan={5}>No IPs in inventory.</td></tr>
                        )}
                        </Table>
                    )}
                    </div>
                </div>
            </div>
        </div>
        </div>
    );
}

---------- END OF FILE: hids-web/src/pages/Reports.jsx ----------


---------- START OF FILE: hids-web/src/pages/Surveillance.jsx ----------

// src/pages/Surveillance.jsx
import { useEffect, useState } from "react";
import { useAuth } from "../context/AuthProvider";
import { api } from "../lib/api";
import IconButton from "../components/IconButton";
import { Pencil, ScanLine, Trash2, Upload } from "lucide-react";

const FREQS = ["minutely", "hourly", "daily"];

/* --------------------------------------------------------------
   Utils
-------------------------------------------------------------- */
function stripAndNormalizePath(raw) {
  if (!raw) return "";
  let s = String(raw).trim();
  // supprime les guillemets si “Copy as path” (Windows/macOS) les ajoute
  if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
    s = s.slice(1, -1);
  }
  // normalise / et \
  s = s.replace(/\\\\+/g, "\\").replace(/\/{2,}/g, "/");
  return s;
}

/* --------------------------------------------------------------
   Modal: Edit frequency (affichage uniquement + édition via crayon)
-------------------------------------------------------------- */
function EditFrequencyModal({ open, onClose, item, onSave }) {
  const [freq, setFreq] = useState(item?.frequency || "hourly");
  useEffect(() => setFreq(item?.frequency || "hourly"), [item]);
  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/60" onClick={onClose} />
      <div className="relative z-10 w-[420px] rounded-xl bg-panel p-4 border border-white/10 shadow-lg">
        <div className="text-lg font-medium mb-3">Edit frequency</div>

        <div className="space-y-2">
          <div className="text-sm text-muted">
            {item?.path || item?.ip || item?.hostname || "entity"}
          </div>
          <label className="text-xs text-muted">Frequency</label>
          <select
            value={freq}
            onChange={(e) => setFreq(e.target.value)}
            className="w-full bg-panel2 border border-white/10 rounded-md text-sm px-2 py-2 focus:outline-none"
          >
            {FREQS.map((f) => (
              <option key={f} value={f}>
                {f}
              </option>
            ))}
          </select>
        </div>

        <div className="mt-4 flex justify-end gap-2">
          <button
            className="px-3 py-1 rounded-md bg-panel/50 border border-white/10 hover:bg-panel transition"
            onClick={onClose}
          >
            Cancel
          </button>
          <button
            className="px-3 py-1 rounded-md bg-green-600 hover:bg-green-500 text-white transition"
            onClick={() => onSave(freq)}
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}

/* --------------------------------------------------------------
    Modal: Add file/folder (helper local + instruction copier/coller)
-------------------------------------------------------------- */
function AddPathModal({ open, onClose, kind, onSave }) {
  const [path, setPath] = useState("");
  const [frequency, setFrequency] = useState("hourly");
  const [helperHint, setHelperHint] = useState(""); // juste pour afficher le nom/indice

  useEffect(() => {
    if (open) {
      setPath("");
      setFrequency("hourly");
      setHelperHint("");
    }
  }, [open]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/60" onClick={onClose} />
      <div className="relative z-10 w-[520px] rounded-xl bg-panel p-4 border border-white/10 shadow-lg">
        <div className="text-lg font-medium mb-4">
          {kind === "files" ? "Add File" : "Add Folder"}
        </div>

        <div className="grid gap-3">
          {/* PATH */}
          <div className="grid gap-2">
            <label className="text-xs text-muted">Absolute path (server)</label>
            <input
              value={path}
              onChange={(e) => setPath(stripAndNormalizePath(e.target.value))}
              placeholder={kind === "files" ? "/etc/hosts" : "/var/log"}
              className="bg-panel2 border border-white/10 rounded-md px-3 py-2"
            />

            <div className="flex items-center gap-2">
              {/* Helper: ouvre le sélecteur local pour récupérer un indice (nom) */}
              <button
                type="button"
                className="px-2 py-1 rounded-md border border-white/10 bg-panel2 flex items-center gap-2"
                onClick={() => {
                  const inp = document.createElement("input");
                  inp.type = "file";
                  if (kind === "folders") inp.webkitdirectory = true;
                  inp.onchange = (ev) => {
                    const f = ev.target.files?.[0];
                    if (!f) return;
                    const hint =
                      kind === "folders"
                        ? (f.webkitRelativePath?.split("/")[0] || "")
                        : (f.name || "");
                    setHelperHint(hint);
                  };
                  inp.click();
                }}
                title={kind === "files" ? "Choose file (helper)" : "Choose folder (helper)"}
              >
                <Upload size={16} />
                {kind === "files" ? "Choose file" : "Choose folder"}
              </button>

              <span className="text-xs text-muted">
                Le navigateur ne peut pas lire les chemins absolus. <b>Faites un clic droit</b> sur
                le fichier/dossier dans votre OS → <b>Copier le chemin complet</b> puis collez‑le ci‑dessus.
              </span>
            </div>

            {helperHint && (
              <div className="text-xs text-muted">
                Helper picked: <span className="text-white/80">{helperHint}</span> (nom seulement)
              </div>
            )}

            <div className="text-[11px] leading-relaxed text-muted mt-1">
              Tips:
              <ul className="list-disc pl-4">
                <li>Windows: Shift + clic droit → “Copy as path”.</li>
                <li>macOS: clic droit → maintenir <b>Option</b> → “Copy “…” as Pathname”.</li>
                <li>Linux: la plupart des explorateurs ont “Copy location”.</li>
                <li>Les guillemets autour du chemin seront retirés automatiquement.</li>
              </ul>
            </div>
          </div>

          {/* FREQUENCY */}
          <div className="grid gap-2">
            <label className="text-xs text-muted">Frequency</label>
            <select
              value={frequency}
              onChange={(e) => setFrequency(e.target.value)}
              className="bg-panel2 border border-white/10 rounded-md text-sm px-2 py-2"
            >
              {FREQS.map((f) => (
                <option key={f} value={f}>
                  {f}
                </option>
              ))}
            </select>
          </div>
        </div>

        <div className="mt-4 flex justify-end gap-2">
          <button className="px-3 py-1.5 rounded-md bg-panel/50 border border-white/10" onClick={onClose}>
            Cancel
          </button>
          <button
            className="px-3 py-1.5 rounded-md bg-green-600 hover:bg-green-500 text-white transition disabled:opacity-50"
            onClick={() => onSave({ path: stripAndNormalizePath(path), frequency })}
            disabled={!stripAndNormalizePath(path)}
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}

/* --------------------------------------------------------------
    Modal: Add IP
-------------------------------------------------------------- */
function AddIpModal({ open, onClose, onSave }) {
  const [ip, setIp] = useState("");
  const [hostname, setHostname] = useState("");
  const [frequency, setFrequency] = useState("hourly");

  useEffect(() => {
    if (open) {
      setIp("");
      setHostname("");
      setFrequency("hourly");
    }
  }, [open]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/60" onClick={onClose} />
      <div className="relative z-10 w-[460px] rounded-xl bg-panel p-4 border border-white/10 shadow-lg">
        <div className="text-lg font-medium mb-4">Add IP</div>

        <div className="grid gap-3">
          <div className="grid gap-2">
            <label className="text-xs text-muted">IP address</label>
            <input
              value={ip}
              onChange={(e) => setIp(e.target.value)}
              placeholder="10.0.0.1"
              className="bg-panel2 border border-white/10 rounded-md px-3 py-2"
            />
          </div>
          <div className="grid gap-2">
            <label className="text-xs text-muted">Hostname (optional)</label>
            <input
              value={hostname}
              onChange={(e) => setHostname(e.target.value)}
              placeholder="lab"
              className="bg-panel2 border border-white/10 rounded-md px-3 py-2"
            />
          </div>
          <div className="grid gap-2">
            <label className="text-xs text-muted">Frequency</label>
            <select
              value={frequency}
              onChange={(e) => setFrequency(e.target.value)}
              className="bg-panel2 border border-white/10 rounded-md text-sm px-2 py-2"
            >
              {FREQS.map((f) => (
                <option key={f} value={f}>
                  {f}
                </option>
              ))}
            </select>
          </div>
        </div>

        <div className="mt-4 flex justify-end gap-2">
          <button
            className="px-3 py-1 rounded-md bg-panel/50 border border-white/10"
            onClick={onClose}
          >
            Cancel
          </button>
          <button
            className="px-3 py-1 rounded-md bg-green-600 hover:bg-green-700 text-white transition disabled:opacity-50"
            onClick={() => onSave({ ip, hostname, frequency })}
            disabled={!ip}
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
}

/* --------------------------------------------------------------
    Page
-------------------------------------------------------------- */
export default function Surveillance() {
  const { token } = useAuth();
  const [tab, setTab] = useState("files"); // 'files' | 'folders' | 'ips'
  const [rows, setRows] = useState([]);
  const [loading, setLoading] = useState(false);

  // Modals
  const [editing, setEditing] = useState(null); // { entity, item }
  const [openAddFile, setOpenAddFile] = useState(false);
  const [openAddFolder, setOpenAddFolder] = useState(false);
  const [openAddIp, setOpenAddIp] = useState(false);

  // API maps
  const loaders = {
    files: () => api.listFiles(token),
    folders: () => api.listFolders(token),
    ips: () => api.listIps(token),
  };
  const deleters = {
    files: (id) => api.deleteFile(token, id),
    folders: (id) => api.deleteFolder(token, id),
    ips: (id) => api.deleteIp(token, id),
  };
  const scanners = {
    files: (id) => api.scanNowFile(token, id),
    folders: (id) => api.scanNowFolder(token, id),
    ips: (id) => api.scanNowIp(token, id),
  };
  const updaters = {
    files: (id, body) => api.updateFile(token, id, body),
    folders: (id, body) => api.updateFolder(token, id, body),
    ips: (id, body) => api.updateIp(token, id, body),
  };
  const creators = {
    files: (data) => api.createFile(token, data),
    folders: (data) => api.createFolder(token, data),
    ips: (data) => api.createIp(token, data),
  };

  const reload = async () => {
    setLoading(true);
    try {
      const data = await loaders[tab]();
      setRows(Array.isArray(data) ? data : data?.items || []);
    } catch (e) {
      console.error("load failed", e);
      setRows([]);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    reload().catch(console.error);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tab, token]);

  const onScan = async (id) => {
    await scanners[tab](id).catch(console.error);
  };

  const onDelete = async (id) => {
    if (!confirm("Delete item?")) return;
    await deleters[tab](id).catch(console.error);
    await reload();
  };

  const openEdit = (item) => setEditing({ entity: tab, item });

  const saveEdit = async (newFreq) => {
    if (!editing) return;
    const { entity, item } = editing;
    try {
      await updaters[entity](item.id, { frequency: newFreq });
      setEditing(null);
      await reload();
    } catch (e) {
      console.error("update failed", e);
    }
  };

  const openAdd = () => {
    if (tab === "files") setOpenAddFile(true);
    else if (tab === "folders") setOpenAddFolder(true);
    else setOpenAddIp(true);
  };

  const submitAddFile = async ({ path, frequency }) => {
    try {
      await creators.files({ path, frequency, status: "active" });
      setOpenAddFile(false);
      await reload();
    } catch (e) {
      console.error("create file failed", e);
    }
  };
  const submitAddFolder = async ({ path, frequency }) => {
    try {
      await creators.folders({ path, frequency, status: "active" });
      setOpenAddFolder(false);
      await reload();
    } catch (e) {
      console.error("create folder failed", e);
    }
  };
  const submitAddIp = async ({ ip, hostname, frequency }) => {
    try {
      await creators.ips({ ip, hostname, frequency, status: "active" });
      setOpenAddIp(false);
      await reload();
    } catch (e) {
      console.error("create ip failed", e);
    }
  };

  return (
    <div className="space-y-4">
      {/* Tabs + Add */}
      <div className="flex items-center justify-between">
        <div className="flex gap-2">
          {["files", "folders", "ips"].map((t) => (
            <button
              key={t}
              onClick={() => setTab(t)}
              className={`px-3 py-1.5 rounded-md border capitalize ${
                tab === t ? "bg-panel2 border-white/10" : "bg-panel/50 border-white/5"
              }`}
            >
              {t}
            </button>
          ))}
        </div>

        <button
          onClick={openAdd}
          className="px-3 py-1.5 rounded-md border border-white/10 bg-panel2 hover:bg-panel transition"
        >
          + Add
        </button>
      </div>

      {/* Table */}
      <div className="card p-0 overflow-hidden">
        <table className="w-full text-sm">
          <thead className="bg-white/5 text-muted">
            <tr>
              <th className="text-left px-4 py-3 w-[45%]">Path / IP</th>
              <th className="text-left px-4 py-3 w-[20%]">Frequency</th>
              <th className="text-left px-4 py-3 w-[15%]">Status</th>
              <th className="text-right px-4 py-3 w-[20%]">Actions</th>
            </tr>
          </thead>
          <tbody>
            {loading && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-muted">
                  Loading…
                </td>
              </tr>
            )}
            {!loading && rows.length === 0 && (
              <tr>
                <td colSpan={4} className="px-4 py-6 text-muted">
                  No data
                </td>
              </tr>
            )}
            {!loading &&
              rows.map((it) => (
                <tr key={it.id} className="border-t border-white/5">
                  <td className="px-4 py-3">
                    <div className="text-white truncate">{it.path || it.ip || "-"}</div>
                    {it.hostname && <div className="text-xs text-muted">{it.hostname}</div>}
                  </td>
                  <td className="px-4 py-3">
                    <span className="inline-block rounded-md bg-white/5 border border-white/10 px-2 py-1">
                      {it.frequency || "hourly"}
                    </span>
                  </td>
                  <td className="px-4 py-3">
                    <span
                      className={`badge ${
                        it.status === "active"
                          ? "bg-emerald-500/20 text-emerald-300"   // vert
                          : it.status === "paused"
                          ? "bg-orange-500/20 text-orange-300"     // orange
                          : "bg-red-500/20 text-red-300"           // rouge (stopped ou autre)
                      }`}
                    >
                      {it.status || "inactive"}
                    </span>

                  </td>
                  <td className="px-4 py-3">
                    <div className="flex justify-end gap-2">
                      <IconButton title="Edit" onClick={() => openEdit(it)}>
                        <Pencil size={16} />
                      </IconButton>
                      <IconButton title="Scan now" onClick={() => onScan(it.id)}>
                        <ScanLine size={16} />
                      </IconButton>
                      <IconButton title="Delete" onClick={() => onDelete(it.id)}>
                        <Trash2 size={16} />
                      </IconButton>
                    </div>
                  </td>
                </tr>
              ))}
          </tbody>
        </table>
      </div>

      {/* Modals */}
      <EditFrequencyModal
        open={!!editing}
        item={editing?.item}
        onClose={() => setEditing(null)}
        onSave={saveEdit}
      />

      <AddPathModal
        open={openAddFile}
        kind="files"
        onClose={() => setOpenAddFile(false)}
        onSave={submitAddFile}
      />
      <AddPathModal
        open={openAddFolder}
        kind="folders"
        onClose={() => setOpenAddFolder(false)}
        onSave={submitAddFolder}
      />
      <AddIpModal
        open={openAddIp}
        onClose={() => setOpenAddIp(false)}
        onSave={submitAddIp}
      />
    </div>
  );
}

---------- END OF FILE: hids-web/src/pages/Surveillance.jsx ----------


---------- START OF FILE: hids-web/src/lib/api.js ----------

// src/lib/api.js
const BASE = import.meta.env.VITE_API_BASE || "";
console.log("API base:", BASE);

async function fetchJson(path, { method = "GET", token, body, form } = {}) {
    const url = `${BASE}${path}`;
    const headers = {};
    if (token) headers["Authorization"] = `Bearer ${token}`;
    if (!form) headers["Content-Type"] = "application/json";

    const res = await fetch(url, {
        method,
        headers,
        body: form ? body : body ? JSON.stringify(body) : undefined,
    });

    const ct = res.headers.get("content-type") || "";
    const txt = await res.text();

    if (!res.ok) {
        let data = null;
        try { if (ct.includes("application/json")) data = JSON.parse(txt); } catch {}
        const err = new Error(`HTTP ${res.status} ${res.statusText}`);
        err.status = res.status;
        err.body = data ?? txt;
        throw err;
    }
    try { return ct.includes("application/json") ? JSON.parse(txt) : txt; }
    catch { return txt; }
}

/* -------------------------------- Utilities -------------------------------- */
const qs = (obj = {}) =>
    Object.entries(obj)
        .filter(([, v]) => v !== undefined && v !== null && v !== "")
        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
        .join("&");

/* ------------------------------ Public API --------------------------------- */
export const api = {
    /* ------------------ Auth ------------------ */
    login: (username, password) =>
        fetchJson("/auth/login", {
        method: "POST",
        form: true,
        body: new URLSearchParams({ username, password }),
        }),
    me: (t) => fetchJson("/users/me", { token: t }),

    /* -------------- Monitoring --------------- */
    listFiles:   (t)        => fetchJson("/monitoring/files", { token: t }),
    createFile:  (t, d)     => fetchJson("/monitoring/files", { method: "POST", token: t, body: d }),
    updateFile:  (t, id, d) => fetchJson(`/monitoring/files/${id}`, { method: "PUT", token: t, body: d }),
    deleteFile:  (t, id)    => fetchJson(`/monitoring/files/${id}`, { method: "DELETE", token: t }),
    scanNowFile: (t, id)    => fetchJson(`/monitoring/files/${id}/scan-now`, { method: "POST", token: t }),

    listFolders: (t)        => fetchJson("/monitoring/folders", { token: t }),
    createFolder:(t, d)     => fetchJson("/monitoring/folders", { method: "POST", token: t, body: d }),
    updateFolder:(t, id, d) => fetchJson(`/monitoring/folders/${id}`, { method: "PUT", token: t, body: d }),
    deleteFolder:(t, id)    => fetchJson(`/monitoring/folders/${id}`, { method: "DELETE", token: t }),
    scanNowFolder:(t, id)   => fetchJson(`/monitoring/folders/${id}/scan-now`, { method: "POST", token: t }),

    listIps:     (t)        => fetchJson("/monitoring/ips", { token: t }),
    createIp:    (t, d)     => fetchJson("/monitoring/ips", { method: "POST", token: t, body: d }),
    updateIp:    (t, id, d) => fetchJson(`/monitoring/ips/${id}`, { method: "PUT", token: t, body: d }),
    deleteIp:    (t, id)    => fetchJson(`/monitoring/ips/${id}`, { method: "DELETE", token: t }),
    scanNowIp:   (t, id)    => fetchJson(`/monitoring/ips/${id}/scan-now`, { method: "POST", token: t }),

    setFileFreq:   (t, id, frequency) => fetchJson(`/monitoring/files/${id}`,   { method: "PUT", token: t, body: { frequency } }),
    setFolderFreq: (t, id, frequency) => fetchJson(`/monitoring/folders/${id}`, { method: "PUT", token: t, body: { frequency } }),
    setIpFreq:     (t, id, frequency) => fetchJson(`/monitoring/ips/${id}`,     { method: "PUT", token: t, body: { frequency } }),

    /* ----------------- Metrics/Reports ---------------- */
    metrics: (t) => fetchJson("/metrics?limit_events=10", { token: t }),
    reports: (t) => fetchJson("/reports?limit_events=50", { token: t }),

    /* ---------------- Alerts & Activity (LOG FILE FIRST) --------------- */
    listHidsLog: async (t, { type = "activity", page = 1, limit = 10, level = "", contains = "" } = {}) => {
        try {
        const r = await fetchJson(`/logs/hids?${qs({ log_type: type, page, limit, level, contains })}`, { token: t });
        return { lines: r.lines, page_count: r.page_count, total: r.total };
        } catch (e) {
        // Fallback si l’endpoint n’existe pas encore
        if (e.status === 404) {
            if (type === "activity") {
            const a = await fetchJson(`/activity?${qs({ limit, offset: (page - 1) * limit })}`, { token: t });
            const items = a?.items || a || [];
            return { lines: items.map(x => ({ ts: x.ts, level: x.level || "INFO", source: x.kind || x.entity_type, msg: x.message || x.raw || "" })), page_count: 1, total: items.length };
            } else {
            const al = await fetchJson(`/alerts?${qs({ limit, offset: (page - 1) * limit })}`, { token: t });
            const items = al?.items || al || [];
            return { lines: items.map(x => ({ ts: x.ts, level: x.severity || "INFO", source: x.entity_type, msg: x.message || "" })), page_count: 1, total: items.length };
            }
        }
        throw e;
        }
    },
    clearHidsLog: (t, type) =>
        fetchJson("/logs/hids/clear", { method: "POST", token: t, body: { type } }),
    // purge avancée: type=activity|alerts, level=..., from=ISO, to=ISO
    purgeHidsLog: (t, { type, level, from, to }) =>
        fetchJson("/logs/hids/purge", { method: "POST", token: t, body: { type, level, from, to } }),

    // Compat list
    listAlerts: (t, { limit, offset, severity, entity_type } = {}) =>
        fetchJson(`/alerts?${qs({ limit, offset, severity, entity_type })}`, { token: t })
        .then((res) => Array.isArray(res) ? ({ items: res, total: res.length }) :
            ({ items: res.items || [], total: res.total ?? res.count ?? (res.items || []).length })),
    listActivity: (t, { limit, offset, kind, entity_type } = {}) =>
        fetchJson(`/activity?${qs({ limit, offset, kind, entity_type })}`, { token: t })
        .then((res) => Array.isArray(res) ? ({ items: res, total: res.length }) :
            ({ items: res.items || [], total: res.total ?? res.count ?? (res.items || []).length })),

    /* ---------------- Users (Settings) --------------- */
    listUsers:   (t)                 => fetchJson("/users", { token: t }),
    createUser:  (t, { username, email, password, is_admin }) =>
        fetchJson("/users", { method: "POST", token: t, body: { username, email, password, is_admin: !!is_admin } }),
//     updateUserPassword: (t, id, { password }) =>
//         fetchJson(`/users/${id}/password`, { method: "PUT", token: t, body: { password } }),
    updateUserPassword: (t, id, { password }) =>
    fetchJson(`/users/${id}/password`, {
        method: "PUT",
        token: t,
        body: { new_password: password }   // <-- attendu par l’API
    }),
    
    deleteUser:  (t, id)             => fetchJson(`/users/${id}`, { method: "DELETE", token: t }),

    /* ---------------- Engine all-in-one --------------- */
    engineState: (t)                 => fetchJson("/engine/state", { token: t }),
    startAll:    (t)                 => fetchJson("/engine/all/start", { method: "POST", token: t }),
    stopAll:     (t)                 => fetchJson("/engine/all/stop",  { method: "POST", token: t }),


    /* ---------------- Engine controls individuels --------------- */
    pauseAllFiles:    (t) => fetchJson("/engine/file/pause-all", { method: "POST", token: t }),
    resumeAllFiles:   (t) => fetchJson("/engine/file/resume-all", { method: "POST", token: t }),
    stopAllFiles:     (t) => fetchJson("/engine/file/stop-all", { method: "POST", token: t }),

    pauseAllFolders:  (t) => fetchJson("/engine/folder/pause-all", { method: "POST", token: t }),
    resumeAllFolders: (t) => fetchJson("/engine/folder/resume-all", { method: "POST", token: t }),
    stopAllFolders:   (t) => fetchJson("/engine/folder/stop-all", { method: "POST", token: t }),

    pauseAllIps:      (t) => fetchJson("/engine/ip/pause-all", { method: "POST", token: t }),
    resumeAllIps:     (t) => fetchJson("/engine/ip/resume-all", { method: "POST", token: t }),
    stopAllIps:       (t) => fetchJson("/engine/ip/stop-all", { method: "POST", token: t }),

    /* utilitaire */
    fetchJson,
};
export default api;

---------- END OF FILE: hids-web/src/lib/api.js ----------


---------- START OF FILE: hids-web/src/App.jsx ----------

// import { Routes, Route, Navigate } from 'react-router-dom'
// import Login from './pages/Login'
// import Dashboard from './pages/Dashboard'
// import Surveillance from './pages/Surveillance'
// import AlertsLogs from './pages/AlertsLogs'
// import Reports from './pages/Reports'
// import Settings from './pages/Settings'
// import Sidebar from './components/Sidebar'
// import Topbar from './components/Topbar'
// import { useAuth } from './context/AuthProvider'

// function Protected({ children }) {
//   const { token } = useAuth()
//   if (!token) return <Navigate to="/login" replace />
//   return children
// }

// export default function App() {
//   return (
//     <div className="min-h-screen flex">
//       <Routes>
//         <Route path="/login" element={<Login />} />
//         <Route
//           path="/*"
//           element={
//             <Protected>
//               <Layout>
//                 <Routes>
//                   <Route path="/" element={<Navigate to="/dashboard" />} />
//                   <Route path="/dashboard" element={<Dashboard />} />
//                   <Route path="/surveillance" element={<Surveillance />} />
//                   <Route path="/alerts" element={<AlertsLogs />} />
//                   <Route path="/reports" element={<Reports />} />
//                   <Route path="/settings" element={<Settings />} />
//                 </Routes>
//               </Layout>
//             </Protected>
//           }
//         />
//       </Routes>
//     </div>
//   )
// }

// function Layout({ children }) {
//   return (
//     <>
//       {/* Sidebar fixe */}
//       <aside className="w-64 shrink-0">
//         <Sidebar />
//       </aside>

//       {/* Colonne principale (topbar + contenu) */}
//       <div className="flex-1 flex h-screen min-w-0 flex flex-col">
//         <Topbar />

//         {/* Le SEUL scroll vertical est ici */}
//         <main className="flex-1 overflow-auto pt-4 px-6">
//           <div>
//             {children}
//           </div>
//         </main>
//       </div>
//     </>
//   )
// }


import { Routes, Route, Navigate } from "react-router-dom";
import Login from "./pages/Login";
import Dashboard from "./pages/Dashboard";
import Surveillance from "./pages/Surveillance";
import AlertsLogs from "./pages/AlertsLogs";
import Reports from "./pages/Reports";
import Settings from "./pages/Settings";
import Sidebar from "./components/Sidebar";
import Topbar from "./components/Topbar";
import { useAuth } from "./context/AuthProvider";

function Protected({ children }) {
  const { token } = useAuth();
  if (!token) return <Navigate to="/login" replace />;
  return children;
}

export default function App() {
  return (
    <div className="min-h-screen flex bg-slate-950 text-white">
      {/* Fonds globaux cohérents (dégradé + quadrillage + halos cyan/bleu) */}
      <div className="fixed inset-0 -z-10 bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950" />
      <div className="fixed -top-24 -left-24 -z-10 h-80 w-80 rounded-full bg-cyan-500/15 blur-3xl" />
      <div className="fixed bottom-[-6rem] right-24 -z-10 h-96 w-96 rounded-full bg-blue-500/10 blur-3xl" />
      <div
        className="fixed inset-0 -z-10"
        style={{
          backgroundImage:
            "linear-gradient(to right, rgba(148,163,184,0.06) 1px, transparent 1px)," +
            "linear-gradient(to bottom, rgba(148,163,184,0.06) 1px, transparent 1px)",
          backgroundSize: "32px 32px",
        }}
      />

      <Routes>
        {/* Login page */}
        <Route path="/login" element={<Login />} />

        {/* Routes protégées */}
        <Route
          path="/*"
          element={
            <Protected>
              <Layout>
                <Routes>
                  <Route path="/" element={<Navigate to="/dashboard" />} />
                  <Route path="/dashboard" element={<Dashboard />} />
                  <Route path="/surveillance" element={<Surveillance />} />
                  <Route path="/alerts" element={<AlertsLogs />} />
                  <Route path="/reports" element={<Reports />} />
                  <Route path="/settings" element={<Settings />} />
                </Routes>
              </Layout>
            </Protected>
          }
        />
      </Routes>
    </div>
  );
}

function Layout({ children }) {
  return (
    <>
      {/* Sidebar fixe (design cohérent glassmorphism) */}
      <aside className="w-64 shrink-0 border-r border-white/10 bg-slate-900/70 backdrop-blur-xl">
        <Sidebar />
      </aside>

      {/* Colonne principale (topbar + contenu) */}
      <div className="flex-1 flex h-screen min-w-0 flex-col">
        <Topbar />

        {/* Le SEUL scroll vertical est ici */}
        <main className="flex-1 overflow-auto p-6">
          <div className="min-h-full">{children}</div>
        </main>
      </div>
    </>
  );
}

---------- END OF FILE: hids-web/src/App.jsx ----------


---------- START OF FILE: hids-web/src/main.jsx ----------

// import { StrictMode } from 'react'
// import { createRoot } from 'react-dom/client'
// import './index.css'
// import App from './App.jsx'

// createRoot(document.getElementById('root')).render(
//   <StrictMode>
//     <App />
//   </StrictMode>,
// )


import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App'
import './index.css'
import { AuthProvider } from './context/AuthProvider'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </React.StrictMode>
)

---------- END OF FILE: hids-web/src/main.jsx ----------


---------- START OF FILE: docker-compose.yml ----------

# services:
#   api:
#     build: ./backend
#     env_file:
#       - ./.env
#     environment:
#       JWT_SECRET: "${JWT_SECRET:?JWT_SECRET not set}"
#       LOG_LEVEL: "${LOG_LEVEL:-INFO}"
#       DATABASE_URL: "${DATABASE_URL:-sqlite:///./data/hids.db}"
#     volumes:
#       - ./data:/app/data
#       - ./logs:/app/logs
#       - ./backend/app:/app/app
#     ports:
#       - "8000:8000"


#   # future front-end or other services go here...

# version: "3.9"

services:
  api:
    build: ./backend
    env_file:
      - ./.env
    environment:
      # --- existants ---
      JWT_SECRET: "${JWT_SECRET:?JWT_SECRET not set}"
      LOG_LEVEL: "${LOG_LEVEL:-INFO}"
      DATABASE_URL: "${DATABASE_URL:-sqlite:///./data/hids.db}"

      # --- CORS (pour le front) ---
      # Liste séparée par des virgules (http/https, ports 5173/3000/8443 par ex.)
      ALLOWED_ORIGINS: "${ALLOWED_ORIGINS:-http://localhost:5173,http://localhost:3000,https://localhost:5173,https://localhost:3000,https://localhost:8443}"

      # --- HTTPS optionnel ---
      # Mets SSL_ENABLED=true pour lancer l'API en TLS sur 8443
      SSL_ENABLED: "${SSL_ENABLED:-false}"
      SSL_CERTFILE: "${SSL_CERTFILE:-/app/certs/localhost-cert.pem}"
      SSL_KEYFILE: "${SSL_KEYFILE:-/app/certs/localhost-key.pem}"

      # Logs
      HIDS_LOG_DIR: "${HIDS_LOG_DIR:-/app/logs}"
      
      # - HIDS_LOG_DIR=/app/logs

    volumes:
      - ./backend/app:/app/app           # code
      - ./data:/app/data                 # hids.db + jobs.db (APScheduler)
      - ./logs:/app/logs                 # hids.log
      - ./certs:/app/certs:ro            # certs TLS locaux (si SSL_ENABLED=true)

    ports:
      - "8000:8000"   # HTTP (toujours exposé, utilisé si SSL_ENABLED=false)
      - "8443:8443"   # HTTPS (utilisé si SSL_ENABLED=true)

    # Démarre en HTTPS si demandé, sinon HTTP (port unique actif selon le mode)
    command: >
      sh -c "
        if [ \"$SSL_ENABLED\" = \"true\" ] && [ -f \"$SSL_CERTFILE\" ] && [ -f \"$SSL_KEYFILE\" ]; then
          echo 'Starting API in HTTPS on :8443';
          uvicorn app.main:app --host 0.0.0.0 --port 8443 --ssl-keyfile $SSL_KEYFILE --ssl-certfile $SSL_CERTFILE;
        else
          echo 'Starting API in HTTP on :8000';
          uvicorn app.main:app --host 0.0.0.0 --port 8000;
        fi
      "

    restart: unless-stopped

---------- END OF FILE: docker-compose.yml ----------


