---------- START OF FILE: backend/app/api/monitoring.py ----------

# File: backend/app/api/monitoring.py
from typing import List, Any
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.exc import IntegrityError
from datetime import datetime

# Scheduler + scan tasks
from app.core.scheduler import add_interval_job, remove_job, FREQ_SECONDS
from app.services.scan_tasks import scan_file, scan_folder, scan_ip

# Schemas (Pydantic)
from app.models.monitoring import (
    FileItemCreate, FileItemRead,
    IPItemCreate, IPItemRead,
    FolderItemCreate, FolderItemRead
)

# Services (DB CRUD)
from app.services.monitoring_service import (
    get_file_items, get_file_item, create_file_item, update_file_item, delete_file_item,
    get_ip_items, get_ip_item, create_ip_item, update_ip_item, delete_ip_item,
    get_folder_items, get_folder_item, create_folder_item, update_folder_item, delete_folder_item
)

# Auth
from app.core.security import get_current_active_user
from app.db.models import User as ORMUser  # éventuellement utile

# (optionnel) mini logger
import logging
log = logging.getLogger("monitoring-api")

router = APIRouter(
    prefix="/api/monitoring",
    tags=["monitoring"],
    dependencies=[Depends(get_current_active_user)]
)

# -------------------------------------------------------------------------
# Helpers: support dict OU objet (ORM/Pydantic) de façon uniforme
# -------------------------------------------------------------------------

def _val(obj: Any, name: str, default: Any = None) -> Any:
    """Récupère un champ soit en attribut, soit en clé dict, sinon default."""
    if obj is None:
        return default
    if isinstance(obj, dict):
        return obj.get(name, default)
    return getattr(obj, name, default)

def _schedule_file(item: Any) -> None:
    """(Re)pose un job de scan pour un File si status=active, sinon retire."""
    iid = _val(item, "id")
    if iid is None:
        return
    status = _val(item, "status", "active")
    freq = _val(item, "frequency", "hourly")
    path = _val(item, "path")

    if status == "active":
        sec = FREQ_SECONDS.get(freq, 3600)
        try:
            add_interval_job("file", iid, sec, scan_file, item_id=iid, path=path)
            log.debug(f"[scheduler] file #{iid} scheduled every {sec}s (status={status}, freq={freq})")
        except Exception as e:
            log.warning(f"[scheduler] cannot schedule file #{iid}: {e}")
    else:
        try:
            remove_job("file", iid)
            log.debug(f"[scheduler] file #{iid} job removed (status={status})")
        except Exception as e:
            log.warning(f"[scheduler] cannot remove file job #{iid}: {e}")

def _schedule_folder(item: Any) -> None:
    iid = _val(item, "id")
    if iid is None:
        return
    status = _val(item, "status", "active")
    freq = _val(item, "frequency", "hourly")
    path = _val(item, "path")

    if status == "active":
        sec = FREQ_SECONDS.get(freq, 3600)
        try:
            add_interval_job("folder", iid, sec, scan_folder, item_id=iid, path=path)
            log.debug(f"[scheduler] folder #{iid} scheduled every {sec}s (status={status}, freq={freq})")
        except Exception as e:
            log.warning(f"[scheduler] cannot schedule folder #{iid}: {e}")
    else:
        try:
            remove_job("folder", iid)
            log.debug(f"[scheduler] folder #{iid} job removed (status={status})")
        except Exception as e:
            log.warning(f"[scheduler] cannot remove folder job #{iid}: {e}")

def _schedule_ip(item: Any) -> None:
    iid = _val(item, "id")
    if iid is None:
        return
    status = _val(item, "status", "active")
    freq = _val(item, "frequency", "hourly")
    ip = _val(item, "ip")
    hostname = _val(item, "hostname", None)

    if status == "active":
        sec = FREQ_SECONDS.get(freq, 3600)
        try:
            add_interval_job("ip", iid, sec, scan_ip, item_id=iid, ip=ip, hostname=hostname)
            log.debug(f"[scheduler] ip #{iid} scheduled every {sec}s (status={status}, freq={freq})")
        except Exception as e:
            log.warning(f"[scheduler] cannot schedule ip #{iid}: {e}")
    else:
        try:
            remove_job("ip", iid)
            log.debug(f"[scheduler] ip #{iid} job removed (status={status})")
        except Exception as e:
            log.warning(f"[scheduler] cannot remove ip job #{iid}: {e}")

# -------------------------------------------------------------------------
# File monitoring endpoints
# -------------------------------------------------------------------------

@router.get("/files/{file_id}", response_model=FileItemRead)
def read_file_item(file_id: int):
    """Get a single monitored file by ID."""
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    return item

@router.get("/files", response_model=List[FileItemRead])
def read_file_items(skip: int = 0, limit: int = 100):
    return get_file_items(skip=skip, limit=limit)

@router.post("/files", response_model=FileItemRead, status_code=status.HTTP_201_CREATED)
def add_file_item(file_in: FileItemCreate):
    try:
        item = create_file_item(file_in)
        _schedule_file(item)
        return item
    except IntegrityError:
        raise HTTPException(status_code=409, detail="File path already exists")

@router.put("/files/{file_id}", response_model=FileItemRead)
def edit_file_item(file_id: int, file_in: FileItemCreate):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    item = update_file_item(file_id, file_in)
    _schedule_file(item)
    return item

@router.delete("/files/{file_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_file_item(file_id: int):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    delete_file_item(file_id)
    remove_job("file", file_id)
    return None

# -------------------------------------------------------------------------
# IP monitoring endpoints
# -------------------------------------------------------------------------

@router.get("/ips/{ip_id}", response_model=IPItemRead)
def read_ip_item(ip_id: int):
    """Get a single monitored IP by ID."""
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    return item

@router.get("/ips", response_model=List[IPItemRead])
def read_ip_items(skip: int = 0, limit: int = 100):
    return get_ip_items(skip=skip, limit=limit)

@router.post("/ips", response_model=IPItemRead, status_code=status.HTTP_201_CREATED)
def add_ip_item(ip_in: IPItemCreate):
    try:
        item = create_ip_item(ip_in)
        _schedule_ip(item)
        return item
    except IntegrityError:
        raise HTTPException(status_code=409, detail="IP address already exists")

@router.put("/ips/{ip_id}", response_model=IPItemRead)
def edit_ip_item(ip_id: int, ip_in: IPItemCreate):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    item = update_ip_item(ip_id, ip_in)
    _schedule_ip(item)
    return item

@router.delete("/ips/{ip_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_ip_item(ip_id: int):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    delete_ip_item(ip_id)
    remove_job("ip", ip_id)
    return None

# -------------------------------------------------------------------------
# Folder monitoring endpoints
# -------------------------------------------------------------------------

@router.get("/folders/{folder_id}", response_model=FolderItemRead)
def read_folder_item(folder_id: int):
    """Get a single monitored folder by ID."""
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    return item

@router.get("/folders", response_model=List[FolderItemRead])
def read_folder_items(skip: int = 0, limit: int = 100):
    return get_folder_items(skip=skip, limit=limit)

@router.post("/folders", response_model=FolderItemRead, status_code=status.HTTP_201_CREATED)
def add_folder_item(folder_in: FolderItemCreate):
    try:
        item = create_folder_item(folder_in)
        _schedule_folder(item)
        return item
    except IntegrityError:
        raise HTTPException(status_code=409, detail="Folder already monitored")
    except Exception as e:
        if "UNIQUE constraint failed: monitored_folders.path" in str(e):
            raise HTTPException(status_code=409, detail="Folder already monitored")
        raise

@router.put("/folders/{folder_id}", response_model=FolderItemRead)
def edit_folder_item(folder_id: int, folder_in: FolderItemCreate):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    item = update_folder_item(folder_id, folder_in)
    _schedule_folder(item)
    return item

@router.delete("/folders/{folder_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_folder_item(folder_id: int):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    delete_folder_item(folder_id)
    remove_job("folder", folder_id)
    return None

# -------------------------------------------------------------------------
# Scan now endpoints
# -------------------------------------------------------------------------

@router.post("/files/{file_id}/scan-now")
def scan_now_file(file_id: int):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    # on scanne même si status=paused (action manuelle)
    scan_file(item_id=item["id"] if isinstance(item, dict) else item.id,
                path=item["path"] if isinstance(item, dict) else item.path)
    return {"executed": True, "type": "file_scan", "id": item["id"] if isinstance(item, dict) else item.id,
            "ts": datetime.utcnow().isoformat()}

@router.post("/folders/{folder_id}/scan-now")
def scan_now_folder(folder_id: int):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    scan_folder(item_id=item["id"] if isinstance(item, dict) else item.id,
                path=item["path"] if isinstance(item, dict) else item.path)
    return {"executed": True, "type": "folder_scan", "id": item["id"] if isinstance(item, dict) else item.id,
            "ts": datetime.utcnow().isoformat()}

@router.post("/ips/{ip_id}/scan-now")
def scan_now_ip(ip_id: int):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    scan_ip(item_id=item["id"] if isinstance(item, dict) else item.id,
            ip=item["ip"] if isinstance(item, dict) else item.ip,
            hostname=(item.get("hostname") if isinstance(item, dict) else getattr(item, "hostname", None)))
    return {"executed": True, "type": "ip_scan", "id": item["id"] if isinstance(item, dict) else item.id,
            "ts": datetime.utcnow().isoformat()}
---------- END OF FILE: backend/app/api/monitoring.py ----------


---------- START OF FILE: backend/app/services/monitoring_service.py ----------

# # File: backend/app/services/monitoring_service.py
# from typing import List, Optional
# from sqlalchemy.orm import Session
# from sqlalchemy.exc import NoResultFound
# from sqlalchemy.exc import IntegrityError


# from app.db.session import SessionLocal
# from app.db.models import MonitoredFile, MonitoredIP, MonitoredFolder
# from app.models.monitoring import FileItemCreate, IPItemCreate, FolderItemCreate


# # ---- Monitored Files CRUD ----

# def get_file_items(skip: int = 0, limit: int = 100) -> List[MonitoredFile]:
#     db: Session = SessionLocal()
#     items = db.query(MonitoredFile).offset(skip).limit(limit).all()
#     db.close()
#     return items


# def get_file_item(file_id: int) -> Optional[MonitoredFile]:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
#     db.close()
#     return item



# def create_file_item(file_in: FileItemCreate) -> MonitoredFile:
#     db: Session = SessionLocal()
#     try:
#         existing = db.query(MonitoredFile).filter(MonitoredFile.path == file_in.path).first()
#         if existing:
#             db.close()
#             return existing
#         db_item = MonitoredFile(path=file_in.path, frequency=file_in.frequency)
#         db.add(db_item)
#         db.commit()
#         db.refresh(db_item)
#         db.close()
#         return db_item
#     except IntegrityError:
#         db.rollback()
#         db.close()
#         raise

# def update_file_item(file_id: int, file_in: FileItemCreate) -> MonitoredFile:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
#     if not item:
#         db.close()
#         raise NoResultFound(f"File item {file_id} not found")
#     item.path = file_in.path
#     item.frequency = file_in.frequency
#     db.commit()
#     db.refresh(item)
#     db.close()
#     return item


# def delete_file_item(file_id: int) -> None:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
#     if item:
#         db.delete(item)
#         db.commit()
#     db.close()


# # ---- Monitored IPs CRUD ----

# def get_ip_items(skip: int = 0, limit: int = 100) -> List[MonitoredIP]:
#     db: Session = SessionLocal()
#     items = db.query(MonitoredIP).offset(skip).limit(limit).all()
#     db.close()
#     return items


# def get_ip_item(ip_id: int) -> Optional[MonitoredIP]:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
#     db.close()
#     return item


# def create_ip_item(ip_in: IPItemCreate) -> MonitoredIP:
#     db: Session = SessionLocal()
#     try:
#         existing = db.query(MonitoredIP).filter(MonitoredIP.ip == ip_in.ip).first()
#         if existing:
#             db.close()
#             return existing
#         db_item = MonitoredIP(
#             ip=ip_in.ip,
#             hostname=ip_in.hostname,
#             frequency=ip_in.frequency
#         )
#         db.add(db_item)
#         db.commit()
#         db.refresh(db_item)
#         db.close()
#         return db_item
#     except IntegrityError:
#         db.rollback()
#         db.close()
#         raise


# def update_ip_item(ip_id: int, ip_in: IPItemCreate) -> MonitoredIP:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
#     if not item:
#         db.close()
#         raise NoResultFound(f"IP item {ip_id} not found")
#     item.ip = ip_in.ip
#     item.hostname = ip_in.hostname
#     item.frequency = ip_in.frequency
#     db.commit()
#     db.refresh(item)
#     db.close()
#     return item


# def delete_ip_item(ip_id: int) -> None:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
#     if item:
#         db.delete(item)
#         db.commit()
#     db.close()


# # ---- Monitored Folders CRUD ----

# def get_folder_items(skip: int = 0, limit: int = 100) -> List[MonitoredFolder]:
#     db: Session = SessionLocal()
#     items = db.query(MonitoredFolder).offset(skip).limit(limit).all()
#     db.close()
#     return items


# def get_folder_item(folder_id: int) -> Optional[MonitoredFolder]:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
#     db.close()
#     return item


# def create_folder_item(folder_in: FolderItemCreate) -> MonitoredFolder:
#     db: Session = SessionLocal()
#     try:
        
#         existing = db.query(MonitoredFolder).filter(MonitoredFolder.path == folder_in.path).first()
#         if existing:
#             db.close()
#             return existing
#         db_item = MonitoredFolder(path=folder_in.path, frequency=folder_in.frequency)
#         db.add(db_item); db.commit(); db.refresh(db_item)
#         db.close()
#         return db_item
#     except IntegrityError:
#         db.rollback()
#         db.close()
        
#         raise


# def update_folder_item(folder_id: int, folder_in: FolderItemCreate) -> MonitoredFolder:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
#     if not item:
#         db.close()
#         raise NoResultFound(f"Folder item {folder_id} not found")
#     item.path = folder_in.path
#     item.frequency = folder_in.frequency
#     db.commit()
#     db.refresh(item)
#     db.close()
#     return item


# def delete_folder_item(folder_id: int) -> None:
#     db: Session = SessionLocal()
#     item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
#     if item:
#         db.delete(item)
#         db.commit()
#     db.close()


# # ------------------------------
# # ---- Status update functions ----

# def update_file_status(file_id: int, status: str) -> MonitoredFile:
#     db: Session = SessionLocal()
#     try:
#         item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
#         if not item:
#             raise NoResultFound(f"File item {file_id} not found")

#         if status == "paused":
#             status = "stopped"
#         if status not in {"active", "stopped"}:
#             raise ValueError(f"Unsupported file status: {status}")

#         item.status = status

#         if status == "stopped":
#             # Hard stop: drop hashes so a fresh baseline is rebuilt on next run
#             item.baseline_hash = None
#             item.current_hash = None

#         db.commit()
#         db.refresh(item)
#         return item
#     finally:
#         db.close()


# def update_folder_status(folder_id: int, status: str) -> MonitoredFolder:
#     db: Session = SessionLocal()
#     try:
#         item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
#         if not item:
#             raise NoResultFound(f"Folder item {folder_id} not found")

#         if status == "paused":
#             status = "stopped"
#         if status not in {"active", "stopped"}:
#             raise ValueError(f"Unsupported folder status: {status}")

#         item.status = status

#         if status == "stopped":
#             item.folder_hash = None
#             item.file_count = 0

#         db.commit()
#         db.refresh(item)
#         return item
#     finally:
#         db.close()


# def update_ip_status(ip_id: int, status: str) -> MonitoredIP:
#     db: Session = SessionLocal()
#     try:
#         item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
#         if not item:
#             raise NoResultFound(f"IP item {ip_id} not found")

#         if status == "paused":
#             status = "stopped"
#         if status not in {"active", "stopped"}:
#             raise ValueError(f"Unsupported IP status: {status}")

#         item.status = status

#         if status == "stopped":
#             item.last_status = None

#         db.commit()
#         db.refresh(item)
#         return item
#     finally:
#         db.close()



# File: backend/app/services/monitoring_service.py
import os, re

from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.exc import NoResultFound, IntegrityError

from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredIP, MonitoredFolder
from app.models.monitoring import FileItemCreate, IPItemCreate, FolderItemCreate

# ---- Monitored Files CRUD ----

def get_file_items(skip: int = 0, limit: int = 100) -> List[MonitoredFile]:
    db: Session = SessionLocal()
    items = db.query(MonitoredFile).offset(skip).limit(limit).all()
    db.close()
    return items


def get_file_item(file_id: int) -> Optional[MonitoredFile]:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    db.close()
    return item


def create_file_item(file_in: FileItemCreate) -> MonitoredFile:
    db: Session = SessionLocal()
    try:
        normalized_path = normalize_path(file_in.path)
        existing = db.query(MonitoredFile).filter(MonitoredFile.path == normalized_path).first()
        if existing:
            db.close()
            return existing
        db_item = MonitoredFile(path=normalized_path, frequency=file_in.frequency)
        db.add(db_item)
        db.commit()
        db.refresh(db_item)
        db.close()
        return db_item
    except IntegrityError:
        db.rollback()
        db.close()
        raise



def update_file_item(file_id: int, file_in: FileItemCreate) -> MonitoredFile:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"File item {file_id} not found")
    item.path = file_in.path
    item.frequency = file_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_file_item(file_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ---- Monitored IPs CRUD ----

def get_ip_items(skip: int = 0, limit: int = 100) -> List[MonitoredIP]:
    db: Session = SessionLocal()
    items = db.query(MonitoredIP).offset(skip).limit(limit).all()
    db.close()
    return items


def get_ip_item(ip_id: int) -> Optional[MonitoredIP]:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    db.close()
    return item


def create_ip_item(ip_in: IPItemCreate) -> MonitoredIP:
    db: Session = SessionLocal()
    try:
        existing = db.query(MonitoredIP).filter(MonitoredIP.ip == ip_in.ip).first()
        if existing:
            db.close()
            return existing
        db_item = MonitoredIP(
            ip=ip_in.ip,
            hostname=ip_in.hostname,
            frequency=ip_in.frequency
        )
        db.add(db_item)
        db.commit()
        db.refresh(db_item)
        db.close()
        return db_item
    except IntegrityError:
        db.rollback()
        db.close()
        raise


def update_ip_item(ip_id: int, ip_in: IPItemCreate) -> MonitoredIP:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"IP item {ip_id} not found")
    item.ip = ip_in.ip
    item.hostname = ip_in.hostname
    item.frequency = ip_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_ip_item(ip_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ---- Monitored Folders CRUD ----

def get_folder_items(skip: int = 0, limit: int = 100) -> List[MonitoredFolder]:
    db: Session = SessionLocal()
    items = db.query(MonitoredFolder).offset(skip).limit(limit).all()
    db.close()
    return items


def get_folder_item(folder_id: int) -> Optional[MonitoredFolder]:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    db.close()
    return item


def create_folder_item(folder_in: FolderItemCreate) -> MonitoredFolder:
    db: Session = SessionLocal()
    try:
        existing = db.query(MonitoredFolder).filter(MonitoredFolder.path == folder_in.path).first()
        if existing:
            db.close()
            return existing
        db_item = MonitoredFolder(path=folder_in.path, frequency=folder_in.frequency)
        db.add(db_item); db.commit(); db.refresh(db_item)
        db.close()
        return db_item
    except IntegrityError:
        db.rollback()
        db.close()
        raise


def update_folder_item(folder_id: int, folder_in: FolderItemCreate) -> MonitoredFolder:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"Folder item {folder_id} not found")
    item.path = folder_in.path
    item.frequency = folder_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_folder_item(folder_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ------------------------------
# ---- Status update functions ----

def update_file_status(file_id: int, status: str) -> MonitoredFile:
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
        if not item:
            raise NoResultFound(f"File item {file_id} not found")

        if status not in {"active", "paused", "stopped"}:
            raise ValueError(f"Unsupported file status: {status}")

        item.status = status

        if status == "stopped":
            # Hard stop: drop hashes so a fresh baseline is rebuilt on next run
            item.baseline_hash = None
            item.current_hash = None
        # NOTE: 'paused' NE change rien aux hashes.

        db.commit()
        db.refresh(item)
        return item
    finally:
        db.close()


def update_folder_status(folder_id: int, status: str) -> MonitoredFolder:
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
        if not item:
            raise NoResultFound(f"Folder item {folder_id} not found")

        if status not in {"active", "paused", "stopped"}:
            raise ValueError(f"Unsupported folder status: {status}")

        item.status = status

        if status == "stopped":
            # Arrêt fort: on oublie les états agrégés
            item.folder_hash = None
            item.file_count = 0
        # 'paused' : on ne touche pas

        db.commit()
        db.refresh(item)
        return item
    finally:
        db.close()


def update_ip_status(ip_id: int, status: str) -> MonitoredIP:
    """
    Les IPs n’ont pas de vraie pause métier. On accepte 'paused' pour compat UI,
    mais on traite 'paused' comme 'stopped' côté données (pas de hash à conserver).
    """
    db: Session = SessionLocal()
    try:
        item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
        if not item:
            raise NoResultFound(f"IP item {ip_id} not found")

        if status not in {"active", "paused", "stopped"}:
            raise ValueError(f"Unsupported IP status: {status}")

        # Normaliser: paused -> stopped pour IP
        normalized = "stopped" if status in {"paused", "stopped"} else "active"
        item.status = normalized

        if normalized == "stopped":
            item.last_status = None

        db.commit()
        db.refresh(item)
        return item
    finally:
        db.close()


def normalize_path(path: str) -> str:
    if not path:
        return path
    # Convertir backslashes → slashes
    path = path.replace("\\", "/")
    # Supprimer les espaces début/fin
    path = path.strip()
    # Remplacer doubles slashes par simples (hors protocole type http://)
    path = re.sub(r'(?<!:)//+', '/', path)
    return path

---------- END OF FILE: backend/app/services/monitoring_service.py ----------


---------- START OF FILE: backend/app/main.py ----------

from fastapi import FastAPI, Depends
from fastapi.middleware.cors import CORSMiddleware
from app.core.logging import logger
from app.core.config import settings
from app.db.base import Base
from app.db.session import engine as db_engine
Base.metadata.create_all(bind=db_engine)

from app.core.scheduler import start_scheduler, shutdown_scheduler, add_interval_job, FREQ_SECONDS
from app.services.scan_tasks import scan_file, scan_folder, scan_ip
from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredFolder, MonitoredIP

from app.api.status import router as status_router
from app.api.auth import router as auth_router
from app.api.users import router as users_router
from app.api.monitoring import router as monitoring_router
from app.api.metrics import router as metrics_router
from app.api.reports import router as reports_router
from app.api import engine as engine_routes
from app.api import fs 
# Importation du nouveau routeur unifié pour les logs
from app.api import logs

logger.info(f"Starting {settings.APP_NAME}... (version: {settings.VERSION})")


app = FastAPI(
    title=settings.APP_NAME,
    version=settings.VERSION,
    docs_url="/docs",
    redoc_url="/redoc"
)

# --- CORS ---
origins = [o.strip() for o in settings.ALLOWED_ORIGINS.split(",") if o.strip()]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# @app.on_event("startup")
# def on_startup():
#     """
#     Fonction de démarrage de l'application.
#     """
#     logger.info("Creating database tables (if not exist)...")
    
#     Base.metadata.create_all(bind=db_engine)
#     logger.info("Database ready.")
    
#     start_scheduler()
#     db = SessionLocal()
#     try:
#         for f in db.query(MonitoredFile).filter(MonitoredFile.status == "active").all():
#             sec = FREQ_SECONDS.get(getattr(f, "frequency", "hourly"), 3600)
#             add_interval_job("file", f.id, sec, scan_file, item_id=f.id, path=f.path)
#         for d in db.query(MonitoredFolder).filter(MonitoredFolder.status == "active").all():
#             sec = FREQ_SECONDS.get(getattr(d, "frequency", "hourly"), 3600)
#             add_interval_job("folder", d.id, sec, scan_folder, item_id=d.id, path=d.path)
#         for i in db.query(MonitoredIP).filter(MonitoredIP.status == "active").all():
#             sec = FREQ_SECONDS.get(getattr(i, "frequency", "hourly"), 3600)
#             add_interval_job("ip", i.id, sec, scan_ip, item_id=i.id, ip=i.ip, hostname=i.hostname)
#     finally:
#         db.close()

@app.on_event("startup")
def on_startup():
    """
    Fonction de démarrage de l'application.
    """
    logger.info("Creating database tables (if not exist)...")
    Base.metadata.create_all(bind=db_engine)
    logger.info("Database ready.")
    
    # Démarrer le scheduler d'abord
    start_scheduler()
    logger.info("Scheduler started.")
    
    # Ensuite planifier les jobs
    db = SessionLocal()
    try:
        # Vérifier que le scheduler est actif
        from app.core.scheduler import get_scheduler
        scheduler = get_scheduler()
        if not scheduler.running:
            logger.error("Scheduler is not running!")
            return
            
        logger.info("Scheduling existing monitoring jobs...")
        
        for f in db.query(MonitoredFile).filter(MonitoredFile.status == "active").all():
            sec = FREQ_SECONDS.get(getattr(f, "frequency", "hourly"), 3600)
            add_interval_job("file", f.id, sec, scan_file, item_id=f.id, path=f.path)
            logger.info(f"Scheduled file monitoring: {f.path} (every {sec}s)")
            
        for d in db.query(MonitoredFolder).filter(MonitoredFolder.status == "active").all():
            sec = FREQ_SECONDS.get(getattr(d, "frequency", "hourly"), 3600)
            add_interval_job("folder", d.id, sec, scan_folder, item_id=d.id, path=d.path)
            logger.info(f"Scheduled folder monitoring: {d.path} (every {sec}s)")
            
        for i in db.query(MonitoredIP).filter(MonitoredIP.status == "active").all():
            sec = FREQ_SECONDS.get(getattr(i, "frequency", "hourly"), 3600)
            add_interval_job("ip", i.id, sec, scan_ip, item_id=i.id, ip=i.ip, hostname=i.hostname)
            logger.info(f"Scheduled IP monitoring: {i.ip} (every {sec}s)")
            
        logger.info("All monitoring jobs scheduled successfully.")
        
    except Exception as e:
        logger.error(f"Error during startup job scheduling: {e}")
    finally:
        db.close()


@app.on_event("shutdown")
def on_shutdown():
    """
    Fonction d'arrêt de l'application.
    """
    logger.info("Shutting down application...")
    
    shutdown_scheduler()
    
app.include_router(status_router, prefix="/api")
app.include_router(auth_router, prefix="/api")
app.include_router(users_router)
app.include_router(monitoring_router)
# Inclus le nouveau routeur unifié pour les logs
app.include_router(logs.router, prefix="/api")
app.include_router(metrics_router)
app.include_router(reports_router)
app.include_router(engine_routes.router)
app.include_router(fs.router)
---------- END OF FILE: backend/app/main.py ----------


---------- START OF FILE: hids-web/src/lib/api.js ----------

// src/lib/api.js
const BASE = import.meta.env.VITE_API_BASE || "";
console.log("API base:", BASE);

async function fetchJson(path, { method = "GET", token, body, form } = {}) {
    const url = `${BASE}${path}`;
    const headers = {};
    if (token) headers["Authorization"] = `Bearer ${token}`;
    if (!form) headers["Content-Type"] = "application/json";

    const res = await fetch(url, {
        method,
        headers,
        body: form ? body : body ? JSON.stringify(body) : undefined,
    });

    const ct = res.headers.get("content-type") || "";
    const txt = await res.text();

    if (!res.ok) {
        let data = null;
        try { if (ct.includes("application/json")) data = JSON.parse(txt); } catch {}
        const err = new Error(`HTTP ${res.status} ${res.statusText}`);
        err.status = res.status;
        err.body = data ?? txt;
        throw err;
    }
    try { return ct.includes("application/json") ? JSON.parse(txt) : txt; }
    catch { return txt; }
}

/* -------------------------------- Utilities -------------------------------- */
const qs = (obj = {}) =>
    Object.entries(obj)
        .filter(([, v]) => v !== undefined && v !== null && v !== "")
        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
        .join("&");

/* ------------------------------ Public API --------------------------------- */
export const api = {
    /* ------------------ Auth ------------------ */
    login: (username, password) =>
        fetchJson("/auth/login", {
        method: "POST",
        form: true,
        body: new URLSearchParams({ username, password }),
        }),
    me: (t) => fetchJson("/users/me", { token: t }),

    /* -------------- Monitoring --------------- */
    listFiles:   (t)        => fetchJson("/monitoring/files", { token: t }),
    createFile:  (t, d)     => fetchJson("/monitoring/files", { method: "POST", token: t, body: d }),
    updateFile:  (t, id, d) => fetchJson(`/monitoring/files/${id}`, { method: "PUT", token: t, body: d }),
    deleteFile:  (t, id)    => fetchJson(`/monitoring/files/${id}`, { method: "DELETE", token: t }),
    scanNowFile: (t, id)    => fetchJson(`/monitoring/files/${id}/scan-now`, { method: "POST", token: t }),

    listFolders: (t)        => fetchJson("/monitoring/folders", { token: t }),
    createFolder:(t, d)     => fetchJson("/monitoring/folders", { method: "POST", token: t, body: d }),
    updateFolder:(t, id, d) => fetchJson(`/monitoring/folders/${id}`, { method: "PUT", token: t, body: d }),
    deleteFolder:(t, id)    => fetchJson(`/monitoring/folders/${id}`, { method: "DELETE", token: t }),
    scanNowFolder:(t, id)   => fetchJson(`/monitoring/folders/${id}/scan-now`, { method: "POST", token: t }),

    listIps:     (t)        => fetchJson("/monitoring/ips", { token: t }),
    createIp:    (t, d)     => fetchJson("/monitoring/ips", { method: "POST", token: t, body: d }),
    updateIp:    (t, id, d) => fetchJson(`/monitoring/ips/${id}`, { method: "PUT", token: t, body: d }),
    deleteIp:    (t, id)    => fetchJson(`/monitoring/ips/${id}`, { method: "DELETE", token: t }),
    scanNowIp:   (t, id)    => fetchJson(`/monitoring/ips/${id}/scan-now`, { method: "POST", token: t }),

    setFileFreq:   (t, id, frequency) => fetchJson(`/monitoring/files/${id}`,   { method: "PUT", token: t, body: { frequency } }),
    setFolderFreq: (t, id, frequency) => fetchJson(`/monitoring/folders/${id}`, { method: "PUT", token: t, body: { frequency } }),
    setIpFreq:     (t, id, frequency) => fetchJson(`/monitoring/ips/${id}`,     { method: "PUT", token: t, body: { frequency } }),

    /* ----------------- Metrics/Reports ---------------- */
    metrics: (t) => fetchJson("/metrics?limit_events=10", { token: t }),
    reports: (t) => fetchJson("/reports?limit_events=50", { token: t }),

    /* ---------------- Alerts & Activity (LOG FILE FIRST) --------------- */
    listHidsLog: async (t, { type = "activity", page = 1, limit = 10, level = "", contains = "" } = {}) => {
        try {
        const r = await fetchJson(`/logs/hids?${qs({ log_type: type, page, limit, level, contains })}`, { token: t });
        return { lines: r.lines, page_count: r.page_count, total: r.total };
        } catch (e) {
        // Fallback si l’endpoint n’existe pas encore
        if (e.status === 404) {
            if (type === "activity") {
            const a = await fetchJson(`/activity?${qs({ limit, offset: (page - 1) * limit })}`, { token: t });
            const items = a?.items || a || [];
            return { lines: items.map(x => ({ ts: x.ts, level: x.level || "INFO", source: x.kind || x.entity_type, msg: x.message || x.raw || "" })), page_count: 1, total: items.length };
            } else {
            const al = await fetchJson(`/alerts?${qs({ limit, offset: (page - 1) * limit })}`, { token: t });
            const items = al?.items || al || [];
            return { lines: items.map(x => ({ ts: x.ts, level: x.severity || "INFO", source: x.entity_type, msg: x.message || "" })), page_count: 1, total: items.length };
            }
        }
        throw e;
        }
    },
    clearHidsLog: (t, type) =>
        fetchJson("/logs/hids/clear", { method: "POST", token: t, body: { type } }),
    // purge avancée: type=activity|alerts, level=..., from=ISO, to=ISO
    purgeHidsLog: (t, { type, level, from, to }) =>
        fetchJson("/logs/hids/purge", { method: "POST", token: t, body: { type, level, from, to } }),

    // Compat list
    listAlerts: (t, { limit, offset, severity, entity_type } = {}) =>
        fetchJson(`/alerts?${qs({ limit, offset, severity, entity_type })}`, { token: t })
        .then((res) => Array.isArray(res) ? ({ items: res, total: res.length }) :
            ({ items: res.items || [], total: res.total ?? res.count ?? (res.items || []).length })),
    listActivity: (t, { limit, offset, kind, entity_type } = {}) =>
        fetchJson(`/activity?${qs({ limit, offset, kind, entity_type })}`, { token: t })
        .then((res) => Array.isArray(res) ? ({ items: res, total: res.length }) :
            ({ items: res.items || [], total: res.total ?? res.count ?? (res.items || []).length })),

    /* ---------------- Users (Settings) --------------- */
    listUsers:   (t)                 => fetchJson("/users", { token: t }),
    createUser:  (t, { username, email, password, is_admin }) =>
        fetchJson("/users", { method: "POST", token: t, body: { username, email, password, is_admin: !!is_admin } }),
//     updateUserPassword: (t, id, { password }) =>
//         fetchJson(`/users/${id}/password`, { method: "PUT", token: t, body: { password } }),
    updateUserPassword: (t, id, { password }) =>
    fetchJson(`/users/${id}/password`, {
        method: "PUT",
        token: t,
        body: { new_password: password }   // <-- attendu par l’API
    }),
    
    deleteUser:  (t, id)             => fetchJson(`/users/${id}`, { method: "DELETE", token: t }),

    /* ---------------- Engine all-in-one --------------- */
    engineState: (t)                 => fetchJson("/engine/state", { token: t }),
    startAll:    (t)                 => fetchJson("/engine/all/start", { method: "POST", token: t }),
    stopAll:     (t)                 => fetchJson("/engine/all/stop",  { method: "POST", token: t }),


    /* ---------------- Engine controls individuels --------------- */
    pauseAllFiles:    (t) => fetchJson("/engine/file/pause-all", { method: "POST", token: t }),
    resumeAllFiles:   (t) => fetchJson("/engine/file/resume-all", { method: "POST", token: t }),
    stopAllFiles:     (t) => fetchJson("/engine/file/stop-all", { method: "POST", token: t }),

    pauseAllFolders:  (t) => fetchJson("/engine/folder/pause-all", { method: "POST", token: t }),
    resumeAllFolders: (t) => fetchJson("/engine/folder/resume-all", { method: "POST", token: t }),
    stopAllFolders:   (t) => fetchJson("/engine/folder/stop-all", { method: "POST", token: t }),

    pauseAllIps:      (t) => fetchJson("/engine/ip/pause-all", { method: "POST", token: t }),
    resumeAllIps:     (t) => fetchJson("/engine/ip/resume-all", { method: "POST", token: t }),
    stopAllIps:       (t) => fetchJson("/engine/ip/stop-all", { method: "POST", token: t }),

    /* utilitaire */
    fetchJson,
};
export default api;

---------- END OF FILE: hids-web/src/lib/api.js ----------


