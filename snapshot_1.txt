
===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\alerts.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\auth.py =====
# File: backend/app/api/auth.py
from fastapi import APIRouter, HTTPException, status, Depends
from fastapi.security import OAuth2PasswordRequestForm
from app.models.auth import AuthLogin, Token
from app.services.auth_service import authenticate_user, generate_user_token

router = APIRouter(tags=["auth"])


@router.post("/auth/login", response_model=Token)
def login(form_data: AuthLogin):
    """
    Authenticate user and return JWT token.
    """
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
        )
    access_token = generate_user_token(user)
    return {"access_token": access_token, "token_type": "bearer"}


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\configs.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\integrations.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\monitoring.py =====
# File: backend/app/api/monitoring.py
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status

from app.models.monitoring import (
    FileItemCreate, FileItemRead,
    IPItemCreate, IPItemRead,
    FolderItemCreate, FolderItemRead
)
from app.services.monitoring_service import (
    get_file_items, get_file_item, create_file_item, update_file_item, delete_file_item,
    get_ip_items, get_ip_item, create_ip_item, update_ip_item, delete_ip_item,
    get_folder_items, get_folder_item, create_folder_item, update_folder_item, delete_folder_item
)
from app.core.security import get_current_active_user
from app.db.models import User as ORMUser

router = APIRouter(
    prefix="/api/monitoring",
    tags=["monitoring"],
    dependencies=[Depends(get_current_active_user)]
)

# --- File monitoring endpoints ---
@router.get("/files/{file_id}", response_model=FileItemRead)
def read_file_item(file_id: int):
    """Get a single monitored file by ID."""
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    return item

@router.get("/files", response_model=List[FileItemRead])
def read_file_items(skip: int = 0, limit: int = 100):
    return get_file_items(skip=skip, limit=limit)

@router.post("/files", response_model=FileItemRead, status_code=status.HTTP_201_CREATED)
def add_file_item(file_in: FileItemCreate):
    return create_file_item(file_in)

@router.put("/files/{file_id}", response_model=FileItemRead)
def edit_file_item(file_id: int, file_in: FileItemCreate):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    return update_file_item(file_id, file_in)

@router.delete("/files/{file_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_file_item(file_id: int):
    item = get_file_item(file_id)
    if not item:
        raise HTTPException(status_code=404, detail="File not found")
    delete_file_item(file_id)
    return None

# --- IP monitoring endpoints ---
@router.get("/ips/{ip_id}", response_model=IPItemRead)
def read_ip_item(ip_id: int):
    """Get a single monitored IP by ID."""
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    return item

@router.get("/ips", response_model=List[IPItemRead])
def read_ip_items(skip: int = 0, limit: int = 100):
    return get_ip_items(skip=skip, limit=limit)

@router.post("/ips", response_model=IPItemRead, status_code=status.HTTP_201_CREATED)
def add_ip_item(ip_in: IPItemCreate):
    return create_ip_item(ip_in)

@router.put("/ips/{ip_id}", response_model=IPItemRead)
def edit_ip_item(ip_id: int, ip_in: IPItemCreate):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    return update_ip_item(ip_id, ip_in)

@router.delete("/ips/{ip_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_ip_item(ip_id: int):
    item = get_ip_item(ip_id)
    if not item:
        raise HTTPException(status_code=404, detail="IP not found")
    delete_ip_item(ip_id)
    return None

# --- Folder monitoring endpoints ---
@router.get("/folders/{folder_id}", response_model=FolderItemRead)
def read_folder_item(folder_id: int):
    """Get a single monitored folder by ID."""
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    return item

@router.get("/folders", response_model=List[FolderItemRead])
def read_folder_items(skip: int = 0, limit: int = 100):
    return get_folder_items(skip=skip, limit=limit)

@router.post("/folders", response_model=FolderItemRead, status_code=status.HTTP_201_CREATED)
def add_folder_item(folder_in: FolderItemCreate):
    return create_folder_item(folder_in)

@router.put("/folders/{folder_id}", response_model=FolderItemRead)
def edit_folder_item(folder_id: int, folder_in: FolderItemCreate):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    return update_folder_item(folder_id, folder_in)

@router.delete("/folders/{folder_id}", status_code=status.HTTP_204_NO_CONTENT)
def remove_folder_item(folder_id: int):
    item = get_folder_item(folder_id)
    if not item:
        raise HTTPException(status_code=404, detail="Folder not found")
    delete_folder_item(folder_id)
    return None


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\reports.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\status.py =====
from fastapi import APIRouter
from pydantic import BaseModel
from datetime import datetime

router = APIRouter(tags=["status"])

class StatusResponse(BaseModel):
    status: str
    file: str
    folder: str
    ip: str
    timestamp: datetime
    
@router.get("/status", response_model=StatusResponse)
async def get_status():
    """
    R√©cup√®re le statut de l'application.
    """
    # Remplacez ces valeurs par la logique r√©elle pour obtenir le statut
    status = "OK"
    file = "example.txt"
    folder = "/path/to/folder"
    ip = "10.10.1.1"
    timestamp = datetime.now()
    return StatusResponse(
        status=status,
        file=file,
        folder=folder,
        ip=ip,
        timestamp=timestamp
    )


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\users.py =====
# File: backend/app/api/users.py
from fastapi import APIRouter, HTTPException, status, Depends
from typing import List

from app.models.user import UserCreate, UserRead
from app.services.user_service import (
    create_user, 
    get_users, 
    get_user, 
    update_user, 
    delete_user, 
    change_user_password
)
from app.core.security import get_current_active_user

router = APIRouter(prefix="/api", tags=["users"])

# Admin-only decorator
def admin_only(current_user=Depends(get_current_active_user)):
    if not current_user.is_admin:
        raise HTTPException(status_code=403, detail="Admin privileges required")
    return current_user

@router.post(
    "/users",
    response_model=UserRead,
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(admin_only)]
)
def create_user_endpoint(user_in: UserCreate):
    """Create a new user (admin only)."""
    try:
        return create_user(user_in)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get(
    "/users",
    response_model=List[UserRead],
    dependencies=[Depends(admin_only)]
)
def list_users():
    """List all users (admin only)."""
    return get_users()

@router.get(
    "/users/{user_id}",
    response_model=UserRead,
    dependencies=[Depends(admin_only)]
)
def read_user(user_id: int):
    """Get a single user by ID (admin only)."""
    user = get_user(user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@router.put(
    "/users/{user_id}",
    response_model=UserRead,
    dependencies=[Depends(admin_only)]
)
def update_user_endpoint(user_id: int, user_in: UserCreate):
    """Update a user‚Äôs email/role/status (admin only)."""
    user = update_user(user_id, user_in)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

@router.put(
    "/users/{user_id}/password",
    status_code=status.HTTP_204_NO_CONTENT,
    dependencies=[Depends(get_current_active_user)]
)
def change_password_endpoint(user_id: int, new_password: str):
    """
    Change a user‚Äôs password.
    - Admins can change anyone‚Äôs password.
    - Users can only change their own.
    """
    current = get_current_active_user()
    if not (current.is_admin or current.id == user_id):
        raise HTTPException(status_code=403, detail="Not allowed")
    if not change_user_password(user_id, new_password):
        raise HTTPException(status_code=404, detail="User not found")

@router.delete(
    "/users/{user_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    dependencies=[Depends(admin_only)]
)
def delete_user_endpoint(user_id: int):
    """Delete a user (admin only)."""
    if not delete_user(user_id):
        raise HTTPException(status_code=404, detail="User not found")

@router.get("/users/me", response_model=UserRead)
def read_users_me(current_user=Depends(get_current_active_user)):
    """Profile of the authenticated user."""
    return current_user


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\api\webhooks.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\core\__init__.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\core\config.py =====
# backend/app/core/config.py

from pydantic import BaseSettings, Field

class Settings(BaseSettings):
    APP_NAME: str       = "HIDS-Web API"
    VERSION: str        = "2.0.0"
    API_V1_STR: str     = "/api"
    DATABASE_URL: str   = Field("sqlite:///./data/hids.db", env="DATABASE_URL")
    LOG_LEVEL: str      = Field("INFO", env="LOG_LEVEL")
    JWT_SECRET: str     = Field(..., env="JWT_SECRET")

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\core\logging.py =====
import logging
from logging.handlers import RotatingFileHandler
from app.core.config import settings
import os

LOG_PATH = "logs/hids.log"
os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)

handler = RotatingFileHandler(
    LOG_PATH, maxBytes=5*1024*1024, backupCount=5
)
formatter = logging.Formatter(
    "%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
handler.setFormatter(formatter)

logging.basicConfig(
    level=settings.LOG_LEVEL,
    handlers=[handler]
)
logger = logging.getLogger("hids")


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\core\security.py =====
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from app.core.config import settings

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from app.core.config import settings
# from app.services.auth_service import  decode_access_token
from app.db.models import User as ORMUser
from app.db.session import SessionLocal

#JWT constant
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 #delais d'expiration du token


oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a JWT token, embedding 'data' and an expiration.
    
    :param data: Donn√©es √† inclure dans le token.
    :param expires_delta: Dur√©e d'expiration du token.
    :return: Token JWT.
    """
    #traduire en anglais 
    
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.JWT_SECRET, algorithm=ALGORITHM)


def decode_access_token(token: str) -> dict:
    """
    Decode and verify a JWT token, returning the payload or None if invalid.
    
    :param token: Token JWT √† d√©coder.
    :return: Payload du token.
    """
    
    try:
        return jwt.decode(token, settings.JWT_SECRET, algorithms=[ALGORITHM])
    except JWTError:
        return None

def get_current_user(token: str = Depends(oauth2_scheme)) -> ORMUser:
    payload = decode_access_token(token)
    if not payload or "sub" not in payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid authentication credentials")
    username = payload["sub"]
    db = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.username == username).first()
    db.close()
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
    return user

def get_current_active_user(current_user: ORMUser = Depends(get_current_user)) -> ORMUser:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user")
    return current_user


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\db\base.py =====
from sqlalchemy.ext.declarative import as_declarative, declared_attr

@as_declarative()
class Base:
    """
    Base class for all models.
    """

    id: int
    __name__: str

    @declared_attr
    def __tablename__(cls) -> str:
        """
        Generate the table name from the class name.
        """
        return cls.__name__.lower()


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\db\models.py =====
# File: backend/app/db/models.py
import enum
from sqlalchemy import Column, String, Boolean, Integer, DateTime, Enum
from sqlalchemy.sql import func
from app.db.base import Base

class User(Base):
    __tablename__ = "users"

    id             = Column(Integer, primary_key=True, index=True)
    username       = Column(String, unique=True, index=True, nullable=False)
    email          = Column(String, unique=True, index=True, nullable=False)
    password_hash  = Column(String, nullable=False)
    is_active      = Column(Boolean, default=True, nullable=False)
    is_admin       = Column(Boolean, default=False, nullable=False)
    created_at     = Column(DateTime(timezone=True), server_default=func.now())
    updated_at     = Column(DateTime(timezone=True), onupdate=func.now())

class FrequencyEnum(str, enum.Enum):
    minutely = "minutely"
    hourly   = "hourly"
    daily    = "daily"
    weekly   = "weekly"

class StatusEnum(str, enum.Enum):
    active = "active"
    paused = "paused"

class MonitoredFile(Base):
    __tablename__ = "monitored_files"

    id              = Column(Integer, primary_key=True, index=True)
    path            = Column(String, unique=True, nullable=False)
    frequency       = Column(
        Enum(FrequencyEnum, name="frequency_enum"),
        default=FrequencyEnum.hourly,
        nullable=False
    )
    status          = Column(
        Enum(StatusEnum, name="status_enum"),
        default=StatusEnum.active,
        nullable=False
    )
    created_at      = Column(DateTime(timezone=True), server_default=func.now())
    updated_at      = Column(DateTime(timezone=True), onupdate=func.now())

class MonitoredFolder(Base):
    __tablename__ = "monitored_folders"

    id              = Column(Integer, primary_key=True, index=True)
    path            = Column(String, unique=True, nullable=False)
    frequency       = Column(
        Enum(FrequencyEnum, name="frequency_enum"),
        default=FrequencyEnum.hourly,
        nullable=False
    )
    status          = Column(
        Enum(StatusEnum, name="status_enum"),
        default=StatusEnum.active,
        nullable=False
    )
    created_at      = Column(DateTime(timezone=True), server_default=func.now())
    updated_at      = Column(DateTime(timezone=True), onupdate=func.now())

class MonitoredIP(Base):
    __tablename__ = "monitored_ips"

    id              = Column(Integer, primary_key=True, index=True)
    ip              = Column(String, unique=True, nullable=False)
    hostname        = Column(String, nullable=True)
    frequency       = Column(
        Enum(FrequencyEnum, name="frequency_enum"),
        default=FrequencyEnum.hourly,
        nullable=False
    )
    status          = Column(
        Enum(StatusEnum, name="status_enum"),
        default=StatusEnum.active,
        nullable=False
    )
    created_at      = Column(DateTime(timezone=True), server_default=func.now())
    updated_at      = Column(DateTime(timezone=True), onupdate=func.now())


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\db\session.py =====
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(
    settings.DATABASE_URL, 
    connect_args={"check_same_thread": False}
)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\models\alert.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\models\auth.py =====
# File: backend/app/models/auth.py
from pydantic import BaseModel, EmailStr
from typing import Optional


class AuthLogin(BaseModel):
    username: str
    password: str


class Token(BaseModel):
    access_token: str
    token_type: str  # e.g. "bearer"


class TokenData(BaseModel):
    username: Optional[str] = None


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\models\monitoring.py =====
# File: backend/app/models/monitoring.py
from pydantic import BaseModel
from typing import Literal, Optional

class MonitoredItemBase(BaseModel):
    path: str
    frequency: Literal["minutely", "hourly", "daily", "weekly"]
    status: Optional[Literal["active", "paused"]] = "active"

class FileItemCreate(BaseModel):
    path: str
    frequency: Literal["minutely", "hourly", "daily", "weekly"]

class FileItemRead(MonitoredItemBase):
    id: int

    class Config:
        orm_mode = True

class FolderItemCreate(BaseModel):
    path: str
    frequency: Literal["minutely", "hourly", "daily", "weekly"]

class FolderItemRead(MonitoredItemBase):
    id: int

    class Config:
        orm_mode = True

class IPMonitoredBase(BaseModel):
    ip: str
    hostname: Optional[str]
    frequency: Literal["minutely", "hourly", "daily", "weekly"]
    status: Optional[Literal["active", "paused"]] = "active"

class IPItemCreate(IPMonitoredBase):
    pass

class IPItemRead(IPMonitoredBase):
    id: int
    class Config:
        orm_mode = True


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\models\report.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\models\user.py =====
from datetime import datetime
from pydantic import BaseModel, EmailStr

class UserCreate(BaseModel):
    username: str
    email: EmailStr
    password: str
    is_admin: bool = False

class UserRead(BaseModel):
    id: int
    username: str
    email: EmailStr
    is_active: bool
    is_admin: bool
    created_at: datetime

    class Config:
        orm_mode = True


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\services\alert_service.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\services\auth_service.py =====
# File: backend/app/services/auth_service.py
from passlib.context import CryptContext
from app.db.session import SessionLocal
# Import your ORM User model once defined
from app.db.models import User as ORMUser
from app.core.security import create_access_token
from datetime import timedelta
from typing import Optional

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)


def authenticate_user(username: str, password: str):
    """
    Stub: query the database for user, verify password.
    Replace ORMUser import and logic when your User model is ready.
    """
    db = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.username == username).first()
    db.close()
    
    if not user or not verify_password(password, user.password_hash):
        return None
    return user


def generate_user_token(user, expires_minutes: Optional[int] = None) -> str:
    data = {"sub": user.username}
    expire_delta = timedelta(minutes=expires_minutes) if expires_minutes else None
    return create_access_token(data=data, expires_delta=expire_delta)


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\services\monitoring_service.py =====
# File: backend/app/services/monitoring_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from sqlalchemy.exc import NoResultFound

from app.db.session import SessionLocal
from app.db.models import MonitoredFile, MonitoredIP, MonitoredFolder
from app.models.monitoring import FileItemCreate, IPItemCreate, FolderItemCreate


# ---- Monitored Files CRUD ----

def get_file_items(skip: int = 0, limit: int = 100) -> List[MonitoredFile]:
    db: Session = SessionLocal()
    items = db.query(MonitoredFile).offset(skip).limit(limit).all()
    db.close()
    return items


def get_file_item(file_id: int) -> Optional[MonitoredFile]:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    db.close()
    return item


def create_file_item(file_in: FileItemCreate) -> MonitoredFile:
    db: Session = SessionLocal()
    db_item = MonitoredFile(
        path=file_in.path,
        frequency=file_in.frequency
    )
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    db.close()
    return db_item


def update_file_item(file_id: int, file_in: FileItemCreate) -> MonitoredFile:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"File item {file_id} not found")
    item.path = file_in.path
    item.frequency = file_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_file_item(file_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredFile).filter(MonitoredFile.id == file_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ---- Monitored IPs CRUD ----

def get_ip_items(skip: int = 0, limit: int = 100) -> List[MonitoredIP]:
    db: Session = SessionLocal()
    items = db.query(MonitoredIP).offset(skip).limit(limit).all()
    db.close()
    return items


def get_ip_item(ip_id: int) -> Optional[MonitoredIP]:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    db.close()
    return item


def create_ip_item(ip_in: IPItemCreate) -> MonitoredIP:
    db: Session = SessionLocal()
    db_item = MonitoredIP(
        ip=ip_in.ip,
        hostname=ip_in.hostname,
        frequency=ip_in.frequency
    )
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    db.close()
    return db_item


def update_ip_item(ip_id: int, ip_in: IPItemCreate) -> MonitoredIP:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"IP item {ip_id} not found")
    item.ip = ip_in.ip
    item.hostname = ip_in.hostname
    item.frequency = ip_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_ip_item(ip_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredIP).filter(MonitoredIP.id == ip_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


# ---- Monitored Folders CRUD ----

def get_folder_items(skip: int = 0, limit: int = 100) -> List[MonitoredFolder]:
    db: Session = SessionLocal()
    items = db.query(MonitoredFolder).offset(skip).limit(limit).all()
    db.close()
    return items


def get_folder_item(folder_id: int) -> Optional[MonitoredFolder]:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    db.close()
    return item


def create_folder_item(folder_in: FolderItemCreate) -> MonitoredFolder:
    db: Session = SessionLocal()
    db_item = MonitoredFolder(
        path=folder_in.path,
        frequency=folder_in.frequency
    )
    db.add(db_item)
    db.commit()
    db.refresh(db_item)
    db.close()
    return db_item


def update_folder_item(folder_id: int, folder_in: FolderItemCreate) -> MonitoredFolder:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    if not item:
        db.close()
        raise NoResultFound(f"Folder item {folder_id} not found")
    item.path = folder_in.path
    item.frequency = folder_in.frequency
    db.commit()
    db.refresh(item)
    db.close()
    return item


def delete_folder_item(folder_id: int) -> None:
    db: Session = SessionLocal()
    item = db.query(MonitoredFolder).filter(MonitoredFolder.id == folder_id).first()
    if item:
        db.delete(item)
        db.commit()
    db.close()


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\services\report_service.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\services\user_service.py =====
# File: backend/app/services/user_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from app.db.session import SessionLocal
from app.db.models import User as ORMUser
from app.models.user import UserCreate
from app.services.auth_service import get_password_hash


def get_users() -> List[ORMUser]:
    db: Session = SessionLocal()
    users = db.query(ORMUser).all()
    db.close()
    return users


def get_user(user_id: int) -> Optional[ORMUser]:
    db: Session = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.id == user_id).first()
    db.close()
    return user


def create_user(user_in: UserCreate) -> ORMUser:
    db: Session = SessionLocal()
    # V√©rifier qu‚Äôaucun user n‚Äôexiste d√©j√† avec ce mail ou username
    if db.query(ORMUser).filter(ORMUser.email == user_in.email).first():
        db.close()
        raise ValueError("Email already registered")
    if db.query(ORMUser).filter(ORMUser.username == user_in.username).first():
        db.close()
        raise ValueError("Username already taken")

    db_user = ORMUser(
        username=user_in.username,
        email=user_in.email,
        password_hash=get_password_hash(user_in.password),
        is_admin=user_in.is_admin,
        is_active=True
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    db.close()
    return db_user


def update_user(user_id: int, user_in: UserCreate) -> Optional[ORMUser]:
    db: Session = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.id == user_id).first()
    if not user:
        db.close()
        return None
    # Met √† jour email, username, statut admin
    user.username = user_in.username
    user.email = user_in.email
    user.is_admin = user_in.is_admin
    db.commit()
    db.refresh(user)
    db.close()
    return user


def delete_user(user_id: int) -> bool:
    db: Session = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.id == user_id).first()
    if not user:
        db.close()
        return False
    db.delete(user)
    db.commit()
    db.close()
    return True


def change_user_password(user_id: int, new_password: str) -> bool:
    db: Session = SessionLocal()
    user = db.query(ORMUser).filter(ORMUser.id == user_id).first()
    if not user:
        db.close()
        return False
    user.password_hash = get_password_hash(new_password)
    db.commit()
    db.close()
    return True


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\app\main.py =====
from fastapi import FastAPI
from app.core.logging import logger
from app.core.config import settings
from app.db.base import Base
from app.db.session import engine
from app.api.status import router as status_router
from app.api.auth import router as auth_router
from app.api.users import router as users_router
from app.api.monitoring import router as monitoring_router

logger.info(f"Starting {settings.APP_NAME}... (version: {settings.VERSION})")


app = FastAPI(
    title=settings.APP_NAME,
    version=settings.VERSION,
    # version="2.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

@app.on_event("startup")
def on_startup():
    """
    Fonction de d√©marrage de l'application.
    """
    logger.info("Creating database tables (if not exist)...")
    
    Base.metadata.create_all(bind=engine)
    logger.info("Database ready.")

@app.on_event("shutdown")
def on_shutdown():
    """
    Fonction d'arr√™t de l'application.
    """
    logger.info("Shutting down application...")
    
app.include_router(status_router, prefix="/api")
app.include_router(auth_router, prefix="/api")
app.include_router(users_router, prefix="/api")
app.include_router(monitoring_router)


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\Dockerfile =====
# 1. Use a lightweight Python base image
FROM python:3.10-slim

# 2. Set working directory
WORKDIR /app

# 3. Install system dependencies (if any)
RUN apt-get update && apt-get install -y \
    build-essential \
 && rm -rf /var/lib/apt/lists/*

# 4. Copy and install Python requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 5. Copy your backend code
COPY . .

# 6. Create directories for SQLite data and logs, and make them writable
RUN mkdir -p /app/data /app/logs && \
    chmod 755 /app/data /app/logs

# 7. Expose the port your FastAPI app listens on
EXPOSE 8000

# 8. Default command: start Uvicorn with live reload in dev
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\requirements.txt =====
# fastapi>=0.95.0
# uvicorn[standard]>=0.22.0
# sqlalchemy>=1.4.0
# pydantic<2.0.0
# pydantic-settings>=1.0.0
# python-dotenv>=0.21.0

fastapi>=0.95.0
uvicorn[standard]>=0.22.0
sqlalchemy>=1.4
python-dotenv>=0.21
pydantic<2.0.0
# pydantic-settings>=1.0.0
passlib[bcrypt]>=1.7.4
python-jose[cryptography]>=3.3.0
email-validator>=1.1.3


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\backend\task_worker.py =====


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\.env =====
# .env
JWT_SECRET=supersecretkey123
LOG_LEVEL=INFO
DATABASE_URL=sqlite:///./data/hids.db


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\directoy.txt =====
hids_web/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ main.py              # FastAPI() instantiation & router include
‚îÇ   ‚îú‚îÄ‚îÄ core/                # app-wide config & utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py        # Settings (pydantic BaseSettings)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ security.py      # JWT handling, password hashing
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ db/                  # Database setup
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.py       # SessionLocal / engine
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ base.py          # Base class for ORM / models
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/              # Pydantic & (optionally) ORM models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitored_item.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alert.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ report.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/            # Pure-Python business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitoring_service.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alert_service.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ report_service.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ api/                 # FastAPI routers (HTTP layer)
‚îÇ       ‚îú‚îÄ‚îÄ auth.py          # /auth/login, /auth/logout
‚îÇ       ‚îú‚îÄ‚îÄ users.py         # /users CRUD
‚îÇ       ‚îú‚îÄ‚îÄ monitoring.py    # /monitoring/files, /monitoring/ips
‚îÇ       ‚îú‚îÄ‚îÄ alerts.py        # /alerts, /alerts/by-type, /alerts/over-time
‚îÇ       ‚îú‚îÄ‚îÄ reports.py       # /reports, /reports/{id}/download/view/email
‚îÇ       ‚îú‚îÄ‚îÄ integrations.py  # /integrations, /integrations/virustotal
‚îÇ       ‚îú‚îÄ‚îÄ webhooks.py      # /webhooks CRUD
‚îÇ       ‚îî‚îÄ‚îÄ config.py        # /config/access, /updates, /updates/check
‚îÇ
‚îú‚îÄ‚îÄ task_worker.py          # Celery/RQ worker entrypoint
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ requirements.txt






hids-web/
‚îú‚îÄ‚îÄ backend/                            # All server-side code
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.py                     # FastAPI app factory & router includes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/                       # config, security, CORS, settings
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ db/                         # DB session / ORM base
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/                     # Pydantic & (optionally) ORM models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/                   # Business logic (scan, alerts, reports‚Ä¶)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api/                        # FastAPI routers (auth, users, monitoring‚Ä¶)
‚îÇ   ‚îú‚îÄ‚îÄ requirements.txt
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îî‚îÄ‚îÄ task_worker.py                  # Celery / background worker entrypoint
‚îÇ
‚îú‚îÄ‚îÄ frontend/                           # All client-side code (React/Vue/etc.)
‚îÇ   ‚îú‚îÄ‚îÄ public/                         # static assets & index.html
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/                 # reusable UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/                      # Dashboard, Surveillance, Alerts, etc.
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/                   # API client wrappers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx (or .tsx)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.jsx
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js              # if you use Tailwind
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js (or webpack)
‚îÇ
‚îú‚îÄ‚îÄ models.json                         # JSON Schemas (User, MonitoredItem, Alert, Report)
‚îú‚îÄ‚îÄ routes.json                         # Full API inventory
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ docker-compose.yml                  # Brings up frontend + backend + broker + db
‚îú‚îÄ‚îÄ inventaire_routes.md                # Your markdown inventory
‚îî‚îÄ‚îÄ Visuel_anticipe/                    # mockup images
    ‚îú‚îÄ‚îÄ dashboard.png
    ‚îú‚îÄ‚îÄ Alerts&Logs.png
    ‚îú‚îÄ‚îÄ Surveillance_files_folders.png
    ‚îú‚îÄ‚îÄ Surveillance_ip.png
    ‚îî‚îÄ‚îÄ Settings.png



üìë Phase 0 ‚Äì Project & Environment Setup
Goal: Have a reproducible containerized environment and skeleton repo.

Tasks:

Standardize directory layout (as we sketched: app/, core/, db/, models/, services/, api/).

Place backend/Dockerfile and move docker-compose.yml to repo root.

Create empty data/ and logs/ folders; add to .gitignore if needed.

Tests:

docker-compose up --build starts without errors.

curl http://localhost:8000/docs returns the Swagger UI (even if empty).

üõ† Phase 1 ‚Äì Core Infrastructure
Goal: Wire in configuration, database connection, logging, and settings.

Config:

core/config.py loads environment vars (DB path, JWT secret, log level).

Database:

db/session.py sets up SQLAlchemy with SQLite (sqlite:///./data/hids.db).

Create a simple Base model and run a ‚Äúcreate_all()‚Äù on startup.

Logging:

Configure Python logging to write to /app/logs/hids.log with INFO level.

Tests:

Start container, inspect that data/hids.db exists.

Write a tiny script or fixture that opens a session and does a simple query on an empty table.

Check that /app/logs/hids.log is created and contains startup log lines.

üîê Phase 2 ‚Äì Authentication & Security
Goal: Implement JWT-based login/logout and password hashing.

Models: Pydantic schemas for AuthLogin and AuthResponse.

Service: auth_service.py with authenticate_user(), create_access_token().

Router: api/auth.py ‚Üí POST /auth/login, POST /auth/logout.

Tests:

Unit‚Äêtest authenticate_user() against a dummy in-memory user.

Integration test via TestClient:

Valid credentials ‚Üí status 200 + token.

Invalid credentials ‚Üí status 401.

üë§ Phase 3 ‚Äì User Management
Goal: CRUD endpoints for users, with admin-only guards.

Models: UserCreate, UserRead, UserUpdate.

Service: user_service.py methods: create_user(), get_user(), list_users(), update_user(), delete_user().

Router: api/users.py ‚Üí protect with dependency get_current_admin_user().

Tests:

Unit tests for user_service with an in-memory SQLite database.

Integration tests:

Non-admin token cannot call /users ‚Üí 403.

Admin token can list/create/update/delete.

üìÇ Phase 4 ‚Äì Monitoring CRUD
Goal: Files & IPs endpoints to create, read, update, delete monitored items.

Models: MonitoredItemCreate, MonitoredItemRead, MonitoredItemUpdate.

Service: monitoring_service.py handling DB or JSON‚Äêfile persistence.

Router: api/monitoring.py under /monitoring/files and /monitoring/ips.

Tests:

Unit‚Äêtest service methods for adding/updating/deleting items.

Integration tests via TestClient: CRUD scenarios and 404 checks.

üö® Phase 5 ‚Äì Alerts & Logs Retrieval
Goal: Expose stored alerts and logs with filtering & pagination.

Models: AlertRead, LogRead.

Service: alert_service.py, log_service.py that read from DB or files.

Router: api/alerts.py, api/logs.py.

Tests:

Seed the DB with test alerts/logs, verify filters (date range, type, severity) work.

Check pagination headers/body.

üìä Phase 6 ‚Äì Metrics & Status Endpoints
Goal: Implement /status, /metrics/*, /activity endpoints.

Service: status_service.py to gather engine/file/folder/ip state.

Router: api/status.py, api/metrics.py, api/activity.py.

Tests:

Stub the engine states, assert the JSON matches the schema.

Verify time‚Äêseries endpoints return correct intervals.

üìù Phase 7 ‚Äì Reporting
Goal: JSON report generation, plus stubs for HTML, PDF, email.

Models: ReportRequest, ReportRead.

Service: report_service.py‚Äîfor now, produce JSON files under /app/data/reports/{id}.json.

Router: api/reports.py ‚Üí endpoints: generate, list, metadata, download, view, email.

Tests:

Integration tests: generate a report, then GET metadata, GET JSON, GET download stub.

üîó Phase 8 ‚Äì Integrations & Webhooks
Goal: Expose /integrations and /webhooks for external hooks.

Models: Integration, WebhookCreate, WebhookRead.

Service: integration_service.py, webhook_service.py.

Router: api/integrations.py, api/webhooks.py.

Tests:

CRUD webhooks, toggle active flag, simulate a call to a dummy webhook endpoint.

‚úÖ Phase 9 ‚Äì End-to-End & CI
Goal: Wire up pytest + GitHub Actions for automated testing & code quality.

E2E Tests: spin up container, hit /docs, run through key flows (auth ‚Üí user CRUD ‚Üí monitoring ‚Üí alerts ‚Üí report).

CI Pipeline:

lint (flake8/mypy)

pytest --cov

Build Docker image


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\docker-compose.yml =====
services:
  api:
    build: ./backend
    env_file:
      - ./.env
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
      - ./backend/app:/app/app
    ports:
      - "8000:8000"


  # future front-end or other services go here...


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\inventaire_routes.md =====
Voici une **proposition exhaustive** des routes API n√©cessaires, class√©es par √©cran / fonctionnalit√©. Tous les chemins sont en anglais (to ‚Äúmonitoring‚Äù the French ‚Äúsurveillance‚Äù), et chacun indique la m√©thode HTTP, le chemin, ainsi que sa finalit√© et les principaux param√®tres.

---

## 1. Dashboard

**Objectif** : r√©cup√©rer tous les indicateurs et s√©ries de donn√©es pour peupler le tableau de bord en temps r√©el.

| M√©thode | Chemin                   | Description                                       | Query / Body                                 |
| ------- | ------------------------ | ------------------------------------------------- | -------------------------------------------- |
| GET     | `/status`                | √âtat global du HIDS Engine et des sous-moteurs    | ‚Äî                                            |
| GET     | `/metrics/entities`      | Nombre total d‚Äô√©l√©ments surveill√©s                | ‚Äî                                            |
| GET     | `/metrics/alerts/active` | Nombre d‚Äôalertes actives                          | ‚Äî                                            |
| GET     | `/metrics/alerts/latest` | D√©tails de la derni√®re alerte (timestamp, source) | ‚Äî                                            |
| GET     | `/metrics/scans/next`    | Date/heure ou d√©lai avant le prochain scan pr√©vu  | ‚Äî                                            |
| GET     | `/activity`              | Flux d‚Äô√©v√©nements r√©cents (d√©marrages, pauses‚Ä¶)   | `limit` (opt), `since` (opt)                 |
| GET     | `/alerts/by-type`        | Donn√©es pour histogramme ¬´ Alerts by Type ¬ª       | `from`, `to` (opt)                           |
| GET     | `/alerts/over-time`      | S√©rie temporelle des alertes (courbe)             | `from`, `to`, `interval` (opt: `hour`,`day`) |

---

## 2. Monitoring (Files & Folders)

**Objectif** : CRUD sur les fichiers et dossiers √† surveiller.

| M√©thode | Chemin                       | Description                             | Body                                          |              |
| ------- | ---------------------------- | --------------------------------------- | --------------------------------------------- | ------------ |
| GET     | `/monitoring/files`          | Lister tous les fichiers surveill√©s     | ‚Äî                                             |              |
| POST    | `/monitoring/files`          | Ajouter un fichier √† surveiller         | `{ "path": string, "frequency": number }`     |              |
| PUT     | `/monitoring/files/{fileId}` | Mettre √† jour fr√©quence ou statut       | \`{ "frequency"?: number, "status"?: "active" | "paused" }\` |
| DELETE  | `/monitoring/files/{fileId}` | Supprimer un fichier de la surveillance | ‚Äî                                             |              |

---

## 3. Monitoring (IP Addresses)

**Objectif** : CRUD sur les adresses IP √† surveiller.

| M√©thode | Chemin                   | Description                         | Body                                                         |              |
| ------- | ------------------------ | ----------------------------------- | ------------------------------------------------------------ | ------------ |
| GET     | `/monitoring/ips`        | Lister toutes les IP surveill√©es    | ‚Äî                                                            |              |
| POST    | `/monitoring/ips`        | Ajouter une IP √† surveiller         | `{ "ip": string, "hostname"?: string, "frequency": number }` |              |
| PUT     | `/monitoring/ips/{ipId}` | Mettre √† jour fr√©quence ou statut   | \`{ "frequency"?: number, "status"?: "active"                | "paused" }\` |
| DELETE  | `/monitoring/ips/{ipId}` | Supprimer une IP de la surveillance | ‚Äî                                                            |              |

---

## 4. Alerts & Logs

**Objectif** : filtrer et paginer alertes + logs, et exporter si besoin.

| M√©thode | Chemin              | Description                      | Query parameters                                                   |
| ------- | ------------------- | -------------------------------- | ------------------------------------------------------------------ |
| GET     | `/alerts`           | Liste des alertes                | `from`, `to`, `type`, `entityType`, `severity`, `page`, `pageSize` |
| GET     | `/alerts/{alertId}` | D√©tails d‚Äôune alerte             | ‚Äî                                                                  |
| GET     | `/logs`             | Liste des logs (tous events)     | m√™mes filtres que `/alerts` + `source`                             |
| GET     | `/logs/export`      | Export CSV/JSON des logs filtr√©s | m√™mes filtres que `/logs`                                          |

---

## 5. Reports

**Objectif** : g√©n√©rer et t√©l√©charger des rapports summary / detailed.

| M√©thode | Chemin                         | Description                  | Query / Body         |                                        |
| ------- | ------------------------------ | ---------------------------- | -------------------- | -------------------------------------- |
| POST    | `/reports`                     | Lancer g√©n√©ration de rapport | \`{ "type":"summary" | "detailed", "from"\:ISO, "to"\:ISO }\` |
| GET     | `/reports`                     | Lister rapports existants    | `page`, `pageSize`   |                                        |
| GET     | `/reports/{reportId}/download` | R√©cup√©rer le PDF/ZIP g√©n√©r√©  | ‚Äî                    |                                        |

---

## 6. Users & Auth (Settings)

**Objectif** : g√©rer comptes, r√¥les, mots de passe, et droits d‚Äôacc√®s.

| M√©thode | Chemin                     | Description                      | Body                                                    |                |
| ------- | -------------------------- | -------------------------------- | ------------------------------------------------------- | -------------- |
| POST    | `/auth/login`              | Connexion                        | `{ "email":string, "password":string }`                 |                |
| POST    | `/auth/logout`             | D√©connexion                      | ‚Äî                                                       |                |
| GET     | `/users`                   | Lister utilisateurs (admin only) | ‚Äî                                                       |                |
| GET     | `/users/{userId}`          | D√©tails d‚Äôun utilisateur         | ‚Äî                                                       |                |
| POST    | `/users`                   | Cr√©er un utilisateur (admin)     | \`{ "email"\:string, "password"\:string, "role":"admin" | "user" }\`     |
| PUT     | `/users/{userId}`          | Modifier r√¥le/status (admin)     | \`{ "role"?\:string, "status"?: "active"                | "inactive" }\` |
| PUT     | `/users/{userId}/password` | Changer mot de passe             | `{ "new_password":string }`                             |                |
| DELETE  | `/users/{userId}`          | Supprimer utilisateur (admin)    | ‚Äî                                                       |                |

---

## 7. Integrations & Webhooks (Settings)

**Objectif** : configurer API keys et webhooks, activer/d√©sactiver.

| M√©thode | Chemin                     | Description                       | Body                                     |
| ------- | -------------------------- | --------------------------------- | ---------------------------------------- |
| GET     | `/integrations`            | Voir cl√©s/API et webhooks         | ‚Äî                                        |
| PUT     | `/integrations/virustotal` | Enregistrer cl√© VirusTotal (v2.1) | `{ "apiKey": string }`                   |
| POST    | `/webhooks`                | Ajouter un webhook                | `{ "url": string, "active": boolean }`   |
| PUT     | `/webhooks/{webhookId}`    | Modifier un webhook               | `{ "url"?: string, "active"?: boolean }` |
| DELETE  | `/webhooks/{webhookId}`    | Supprimer un webhook              | ‚Äî                                        |

---

## 8. Application Settings (Admin toggles)

**Objectif** : restreindre Reports & Settings aux admins, g√©rer mise √† jour.

| M√©thode | Chemin           | Description                               | Body                                                            |
| ------- | ---------------- | ----------------------------------------- | --------------------------------------------------------------- |
| GET     | `/config/access` | Voir restrictions admin-only              | ‚Äî                                                               |
| PUT     | `/config/access` | Mettre √† jour toggles (reports, settings) | `{ "reportsAdminOnly": boolean, "settingsAdminOnly": boolean }` |
| GET     | `/updates`       | Version actuelle                          | ‚Äî                                                               |
| POST    | `/updates/check` | Forcer recherche de nouvelle version      | ‚Äî                                                               |

---

> üóùÔ∏è **Prochaine √©tape** : valider cette liste ou la compl√©ter (noms, regroupements, filtres) avant de formaliser les JSON schemas de chacun de ces objets (User, MonitoredItem, Alert, Report).


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\models.json =====
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "definitions": {
      "User": {
        "type": "object",
        "required": ["id", "email", "role", "status"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the user"
          },
          "email": {
            "type": "string",
            "format": "email",
            "description": "User's email address"
          },
          "role": {
            "type": "string",
            "enum": ["admin", "user"],
            "description": "Role assigned to the user"
          },
          "password_hash": {
            "type": "string",
            "description": "Password hash (storage only)"
          },
          "last_login": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the user's last login"
          },
          "status": {
            "type": "string",
            "enum": ["active", "inactive"],
            "description": "Account status"
          }
        },
        "additionalProperties": false
      },
  
      "MonitoredItem": {
        "type": "object",
        "required": ["id", "type", "path_or_ip", "frequency", "status"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for this monitored item"
          },
          "type": {
            "type": "string",
            "enum": ["file", "folder", "ip"],
            "description": "Type of the monitored entity"
          },
          "path_or_ip": {
            "type": "string",
            "description": "Filesystem path or IP address"
          },
          "frequency": {
            "type": "integer",
            "minimum": 1,
            "description": "Scan frequency in seconds"
          },
          "status": {
            "type": "string",
            "enum": ["active", "paused"],
            "description": "Monitoring status"
          },
          "last_scan": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of the last scan"
          }
        },
        "additionalProperties": false
      },
  
      "Alert": {
        "type": "object",
        "required": ["id", "timestamp", "source", "severity", "details"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique identifier for the alert"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the alert was generated"
          },
          "source": {
            "type": "string",
            "enum": ["hash", "network"],
            "description": "Alert origin (file-hash change or network event)"
          },
          "severity": {
            "type": "string",
            "enum": ["low", "medium", "high", "critical"],
            "description": "Severity level of the alert"
          },
          "details": {
            "type": "object",
            "description": "Additional data specific to the alert",
            "properties": {
              "path": { "type": "string", "description": "Affected path" },
              "old_hash": { "type": "string", "description": "Previous hash value" },
              "new_hash": { "type": "string", "description": "Updated hash value" },
              "ip": { "type": "string", "description": "Involved IP address" },
              "message": { "type": "string", "description": "Free-form alert message" }
            },
            "additionalProperties": true
          }
        },
        "additionalProperties": false
      },
  
      "Report": {
        "type": "object",
        "required": ["id", "type", "date_generated", "json_url"],
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "description": "Unique report identifier"
          },
          "type": {
            "type": "string",
            "enum": ["summary", "detailed"],
            "description": "Report format requested"
          },
          "date_generated": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp when the report was generated"
          },
          "json_url": {
            "type": "string",
            "format": "uri",
            "description": "URL to retrieve the report JSON"
          },
          "html_url": {
            "type": "string",
            "format": "uri",
            "description": "Webview URL for the HTML report",
            "nullable": true
          },
          "pdf_url": {
            "type": "string",
            "format": "uri",
            "description": "Download URL for the PDF report",
            "nullable": true
          },
          "emailed_to": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "email"
            },
            "description": "List of email addresses the report was sent to",
            "nullable": true
          }
        },
        "additionalProperties": false
      }
    }
  }
  


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\README.md =====
# HIDS-Web

**HIDS-Web** est une interface web l√©g√®re, packag√©e en Docker, pour piloter un syst√®me HIDS (Host-Based Intrusion Detection System).  
Il permet de configurer, lancer, arr√™ter et visualiser vos surveillances de fichiers, dossiers et adresses IP, le tout via un tableau de bord clair.

---

## üöÄ Fonctionnalit√©s (MVP v2.0)

- Configuration des entit√©s √† surveiller (fichiers / dossiers / IP)  
- Statut en temps r√©el du moteur et de chaque type de monitoring  
- Dashboard graphique : cartes de statut, histogramme ‚ÄúAlerts by Type‚Äù, courbe ‚ÄúAlerts Over Time‚Äù  
- Flux d‚Äôactivit√© et logs pagin√©s  
- G√©n√©ration de rapports (summary & detailed)  
- Authentification JWT avec r√¥les **admin** / **user**

---

## üì¶ Architecture

- **Backend** : Python 3.10+, FastAPI, Celery (pour t√¢ches asynchrones), JWT  
- **Base de donn√©es** : SQLite (pour le MVP) ou MongoDB  
- **Frontend** : React (Vite) + Tailwind CSS  
- **Packaging** : Docker Compose (backend, frontend, broker, DB)  

---

## ‚öôÔ∏è Installation rapide

```bash
# Cloner le repo
git clone https://github.com/<ton-orga>/hids-web.git
cd hids-web

# Lancer les services
docker-compose up --build

# Le front est dispo sur http://localhost:3000
# L‚ÄôAPI Swagger sur http://localhost:8000/docs
````

---

## üîß Configuration

* Copier `.env.example` en `.env` et renseigner :

  * `JWT_SECRET`
  * `DATABASE_URL`
  * (plus tard) `VIRUSTOTAL_API_KEY`

---

## üìÖ Roadmap

| Version | Date cible | Feature principale                             |
| ------- | ---------- | ---------------------------------------------- |
| **2.0** | 2025-06-15 | MVP Web App (celui-ci)                         |
| **2.1** | 2025-07-15 | Int√©gration API VirusTotal                     |
| **2.2** | 2025-08-30 | Mod√®le ML de classification d‚ÄôIP malveillantes |

---

## ü§ù Contribuer

1. Forker le projet
2. Cr√©er une branche `feature/‚Ä¶`
3. Commit & PR en d√©crivant bien vos changements
4. Code review & merge

---

hello for Comit

## üìù License

MIT ¬© 2025 Ton Nom


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\routes.json =====
{
  "auth": [
    {
      "method": "POST",
      "path": "/auth/login",
      "description": "Login (returns JWT)",
      "body": {
        "email": "string",
        "password": "string"
      }
    },
    {
      "method": "POST",
      "path": "/auth/logout",
      "description": "Logout (invalidate token)",
      "body": null
    }
  ],

  "users": [
    {
      "method": "GET",
      "path": "/users",
      "description": "List all users (admin only)",
      "query": null
    },
    {
      "method": "GET",
      "path": "/users/{userId}",
      "description": "Get user details",
      "pathParams": {
        "userId": "string"
      }
    },
    {
      "method": "POST",
      "path": "/users",
      "description": "Create a new user (admin only)",
      "body": {
        "email": "string",
        "password": "string",
        "role": "admin | user"
      }
    },
    {
      "method": "PUT",
      "path": "/users/{userId}",
      "description": "Update user role or status (admin only)",
      "pathParams": {
        "userId": "string"
      },
      "body": {
        "role?": "string",
        "status?": "active | inactive"
      }
    },
    {
      "method": "PUT",
      "path": "/users/{userId}/password",
      "description": "Change user password",
      "pathParams": {
        "userId": "string"
      },
      "body": {
        "new_password": "string"
      }
    },
    {
      "method": "DELETE",
      "path": "/users/{userId}",
      "description": "Delete a user (admin only)",
      "pathParams": {
        "userId": "string"
      }
    }
  ],

  "status": [
    {
      "method": "GET",
      "path": "/status",
      "description": "Get global status of HIDS engine and sub-engines",
      "response": {
        "engine": "running | stopped",
        "file": "active | paused",
        "folder": "active | paused",
        "ip": "active | paused"
      }
    }
  ],

  "metrics": [
    {
      "method": "GET",
      "path": "/metrics/entities",
      "description": "Get total number of monitored entities"
    },
    {
      "method": "GET",
      "path": "/metrics/alerts/active",
      "description": "Get count of active alerts"
    },
    {
      "method": "GET",
      "path": "/metrics/alerts/latest",
      "description": "Get details of the latest alert"
    },
    {
      "method": "GET",
      "path": "/metrics/scans/next",
      "description": "Get timestamp or delay until the next scheduled scan"
    }
  ],

  "activity": [
    {
      "method": "GET",
      "path": "/activity",
      "description": "Fetch recent activity events",
      "query": {
        "limit?": "number",
        "since?": "ISO8601 timestamp"
      }
    }
  ],

  "alerts": [
    {
      "method": "GET",
      "path": "/alerts/by-type",
      "description": "Get data for 'Alerts by Type' histogram",
      "query": {
        "from?": "ISO8601",
        "to?": "ISO8601"
      }
    },
    {
      "method": "GET",
      "path": "/alerts/over-time",
      "description": "Get time-series data of alerts",
      "query": {
        "from?": "ISO8601",
        "to?": "ISO8601",
        "interval?": "hour | day"
      }
    },
    {
      "method": "GET",
      "path": "/alerts",
      "description": "List and filter alerts",
      "query": {
        "from?": "ISO8601",
        "to?": "ISO8601",
        "type?": "hash | network",
        "entityType?": "file | folder | ip",
        "severity?": "low | medium | high | critical",
        "page?": "number",
        "pageSize?": "number"
      }
    },
    {
      "method": "GET",
      "path": "/alerts/{alertId}",
      "description": "Get details of a specific alert",
      "pathParams": {
        "alertId": "string"
      }
    }
  ],

  "logs": [
    {
      "method": "GET",
      "path": "/logs",
      "description": "List and filter all logs",
      "query": {
        "from?": "ISO8601",
        "to?": "ISO8601",
        "source?": "hash | network",
        "page?": "number",
        "pageSize?": "number"
      }
    },
    {
      "method": "GET",
      "path": "/logs/export",
      "description": "Export filtered logs (CSV/JSON)",
      "query": {
        "same as /logs": "‚Ä¶"
      }
    }
  ],

  "monitoring": [
    {
      "method": "GET",
      "path": "/monitoring/files",
      "description": "List monitored files"
    },
    {
      "method": "POST",
      "path": "/monitoring/files",
      "description": "Add a file to monitoring",
      "body": {
        "path": "string",
        "frequency": "number"
      }
    },
    {
      "method": "PUT",
      "path": "/monitoring/files/{fileId}",
      "description": "Update monitored file settings",
      "pathParams": {
        "fileId": "string"
      },
      "body": {
        "frequency?": "number",
        "status?": "active | paused"
      }
    },
    {
      "method": "DELETE",
      "path": "/monitoring/files/{fileId}",
      "description": "Remove a file from monitoring"
    },
    {
      "method": "GET",
      "path": "/monitoring/ips",
      "description": "List monitored IPs"
    },
    {
      "method": "POST",
      "path": "/monitoring/ips",
      "description": "Add an IP to monitoring",
      "body": {
        "ip": "string",
        "hostname?": "string",
        "frequency": "number"
      }
    },
    {
      "method": "PUT",
      "path": "/monitoring/ips/{ipId}",
      "description": "Update monitored IP settings",
      "pathParams": {
        "ipId": "string"
      },
      "body": {
        "frequency?": "number",
        "status?": "active | paused"
      }
    },
    {
      "method": "DELETE",
      "path": "/monitoring/ips/{ipId}",
      "description": "Remove an IP from monitoring"
    }
  ],

  "reports": [
    {
      "method": "POST",
      "path": "/reports",
      "description": "Generate a new report",
      "body": {
        "type": "summary | detailed",
        "from": "ISO8601",
        "to": "ISO8601"
      }
    },
    {
      "method": "GET",
      "path": "/reports",
      "description": "List existing reports",
      "query": {
        "page?": "number",
        "pageSize?": "number"
      }
    },
    {
      "method": "GET",
      "path": "/reports/{reportId}",
      "description": "Get report metadata and URLs (JSON, HTML, PDF)",
      "pathParams": {
        "reportId": "string"
      }
    },
    {
      "method": "GET",
      "path": "/reports/{reportId}/download",
      "description": "Download the PDF version of the report",
      "pathParams": {
        "reportId": "string"
      }
    },
    {
      "method": "GET",
      "path": "/reports/{reportId}/view",
      "description": "Render the report as HTML in browser",
      "pathParams": {
        "reportId": "string"
      }
    },
    {
      "method": "POST",
      "path": "/reports/{reportId}/email",
      "description": "Send the report via email",
      "pathParams": {
        "reportId": "string"
      },
      "body": {
        "to": ["string"]
      }
    }
  ],

  "integrations": [
    {
      "method": "GET",
      "path": "/integrations",
      "description": "View API keys and webhooks configuration"
    },
    {
      "method": "PUT",
      "path": "/integrations/virustotal",
      "description": "Save VirusTotal API key",
      "body": {
        "apiKey": "string"
      }
    }
  ],

  "webhooks": [
    {
      "method": "POST",
      "path": "/webhooks",
      "description": "Create a new webhook",
      "body": {
        "url": "string",
        "active": "boolean"
      }
    },
    {
      "method": "PUT",
      "path": "/webhooks/{webhookId}",
      "description": "Update an existing webhook",
      "pathParams": {
        "webhookId": "string"
      },
      "body": {
        "url?": "string",
        "active?": "boolean"
      }
    },
    {
      "method": "DELETE",
      "path": "/webhooks/{webhookId}",
      "description": "Delete a webhook",
      "pathParams": {
        "webhookId": "string"
      }
    }
  ],

  "config": [
    {
      "method": "GET",
      "path": "/config/access",
      "description": "Get admin-only access settings"
    },
    {
      "method": "PUT",
      "path": "/config/access",
      "description": "Update admin-only access toggles",
      "body": {
        "reportsAdminOnly": "boolean",
        "settingsAdminOnly": "boolean"
      }
    },
    {
      "method": "GET",
      "path": "/updates",
      "description": "Get current application version"
    },
    {
      "method": "POST",
      "path": "/updates/check",
      "description": "Trigger a check for new application version"
    }
  ]
}


===== C:\Users\tapso\OneDrive\Documents\GitHub\HIDS2.0\tree.txt =====
Structure du dossier pour le volume Windows
Le num ro de s rie du volume est 26D4-DE23
C:.
    .env
    .gitattributes
    directoy.txt
    docker-compose.yml
    inventaire_routes.md
    models.json
    README.md
    routes.json
    tree.txt
    
            
+---backend
        Dockerfile
        requirements.txt
        task_worker.py
        
    +---app
            main.py
            
        +---api
                alerts.py
                auth.py
                configs.py
                integrations.py
                monitoring.py
                reports.py
                status.py
                users.py
                webhooks.py
                
            +---__pycache__
                    auth.cpython-310.pyc
                    monitoring.cpython-310.pyc
                    status.cpython-310.pyc
                    users.cpython-310.pyc
                    
        +---core
                config.py
                logging.py
                security.py
                __init__.py
                
            +---__pycache__
                    config.cpython-310.pyc
                    logging.cpython-310.pyc
                    security.cpython-310.pyc
                    __init__.cpython-310.pyc
                    
        +---db
                base.py
                models.py
                session.py
                
            +---__pycache__
                    base.cpython-310.pyc
                    models.cpython-310.pyc
                    session.cpython-310.pyc
                    
        +---models
                alert.py
                auth.py
                monitoring.py
                report.py
                user.py
                
            +---__pycache__
                    auth.cpython-310.pyc
                    monitoring.cpython-310.pyc
                    user.cpython-310.pyc
                    
        +---services
                alert_service.py
                auth_service.py
                monitoring_service.py
                report_service.py
                user_service.py
                
            +---__pycache__
                    auth_service.cpython-310.pyc
                    monitoring_service.cpython-310.pyc
                    user_service.cpython-310.pyc
                    
        +---__pycache__
                main.cpython-310.pyc
                
+---data
        hids - Copie.sql
        hids.db
        
+---img
        Alerts&Logs.png
        dashboard.png
        Settings.png
        Surveillance_files_folders.png
        Surveillance_ip.png
        
+---logs
        hids.log
        

